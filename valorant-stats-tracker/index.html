<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VALORANT 戦績トラッカー</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            margin: 0;
            background: linear-gradient(135deg, #0f1419 0%, #1a252f 50%, #2d3748 100%);
            min-height: 100vh;
            color: white;
        }
        .tier-s { background-color: #3B82F6; color: white; } /* 青 (blue-500) */
        .tier-a { background-color: #22C55E; color: white; } /* 緑 (green-500) */
        .tier-b { background-color: #FACC15; color: #1F2937; } /* 黄 (yellow-400), 文字色: gray-800 */
        .tier-c { background-color: #6B7280; color: white; } /* グレー (gray-500) */
        .tier-d { background-color: #EF4444; color: white; } /* 赤 (red-500) */
        
        /* グローバルリセット */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* レスポンシブヘッダー */
        .app-header {
            position: sticky;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            padding: 0.75rem 0;
            background-color: rgba(15, 25, 35, 0.98);
            border-bottom: 2px solid #ff4655;
            backdrop-filter: blur(15px);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.4);
            z-index: 999;
            transition: all 0.3s ease;
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
            width: 100%;
            min-height: 60px;
        }
        
        .nav-buttons {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .author-section {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #fff;
            flex-shrink: 0;
        }
        
        .author-text {
            margin: 0;
            font-size: 0.85rem;
            font-weight: 600;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            color: #fff;
            display: block;
        }
        
        .author-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #ff4655;
            object-fit: cover;
            flex-shrink: 0;
        }
        .app-header button,
        .app-header a.header-button {
            background-color: #ff4655;
            color: white;
            border: none;
            padding: 0.6rem 1rem;
            margin: 0;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            min-height: 40px;
            box-shadow: 0 2px 8px rgba(255, 70, 85, 0.3);
        }
        .app-header button:hover,
        .app-header a.header-button:hover {
            background-color: #e0303f;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 70, 85, 0.4);
        }
        .app-header button.active,
        .app-header a.header-button.active {
            background-color: #22c55e; /* 緑などでアクティブ状態を示す */
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.5);
            text-decoration: none; /* アクティブ時も下線を消す */
        }
        .hidden {
            display: none !important;
        }
        #showOverlayModeLink {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #showTrackerModeLink {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .author-section {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #fff;
        }
        .author-text {
            margin: 0;
            font-size: 0.9em;
            font-weight: 600;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }
        .author-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #ff4655;
            object-fit: cover;
        }
        
        /* 背景スタイル */
        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f1419 0%, #1a252f 50%, #2d3748 100%);
            z-index: -1;
            overflow: hidden;
        }
        
        .background::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 25% 25%, rgba(255, 70, 85, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(59, 130, 246, 0.08) 0%, transparent 50%);
            animation: movePattern 20s ease-in-out infinite;
        }
        
        .background::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(45deg, transparent 49%, rgba(255, 70, 85, 0.02) 50%, transparent 51%),
                linear-gradient(-45deg, transparent 49%, rgba(59, 130, 246, 0.02) 50%, transparent 51%);
            background-size: 60px 60px;
            animation: pulse 4s ease-in-out infinite;
        }
        
        @keyframes movePattern {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            50% { transform: translate(-30px, -30px) rotate(180deg); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* ハンバーガーメニュー */
        .hamburger-menu {
            display: none;
            flex-direction: column;
            justify-content: center;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.3s ease;
            min-width: 40px;
            min-height: 40px;
            background-color: transparent;
            border: 1px solid transparent;
        }
        
        .hamburger-menu:hover {
            background-color: rgba(255, 70, 85, 0.1);
            border-color: rgba(255, 70, 85, 0.3);
        }
        
        .hamburger-line {
            width: 22px;
            height: 2px;
            background-color: #fff;
            margin: 2px 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 2px;
        }
        
        .hamburger-menu.active .hamburger-line:nth-child(1) {
            transform: rotate(45deg) translate(6px, 6px);
        }
        
        .hamburger-menu.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }
        
        .hamburger-menu.active .hamburger-line:nth-child(3) {
            transform: rotate(-45deg) translate(6px, -6px);
        }
        
        .mobile-nav {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(15, 25, 35, 0.98);
            backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255, 70, 85, 0.3);
            padding: 1rem;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border-bottom: 2px solid rgba(255, 70, 85, 0.5);
            animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .mobile-nav.active {
            display: block;
        }
        
        .mobile-nav-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            max-width: 400px;
            margin: 0 auto;
        }
        
        .mobile-nav .header-button {
            width: 100%;
            text-align: center;
            padding: 1rem 1.5rem;
            margin: 0;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            background-color: rgba(255, 70, 85, 0.1);
            border: 1px solid rgba(255, 70, 85, 0.3);
            transition: all 0.3s ease;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .mobile-nav .header-button:hover {
            background-color: rgba(255, 70, 85, 0.2);
            transform: translateY(-1px);
        }
        
        .mobile-nav .header-button.active {
            background-color: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.5);
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* モバイル用マッチカードスタイル */
        @media (max-width: 768px) {
            .match-table-desktop {
                display: none;
            }
            .match-cards-mobile {
                display: block;
            }
            .app-header {
                position: relative;
            }
            
            .header-content {
                justify-content: space-between;
                padding: 0 20px;
            }
            
            .nav-buttons {
                display: none;
            }
            
            .hamburger-menu {
                display: flex;
            }
            
            .author-section {
                margin-top: 0;
            }
        }
        
        @media (min-width: 769px) {
            .match-table-desktop {
                display: block;
            }
            .match-cards-mobile {
                display: none;
            }
        }

        .match-card {
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.8), rgba(55, 65, 81, 0.8));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.3);
        }
        
        .match-card:hover {
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.9), rgba(55, 65, 81, 0.9));
            border-color: rgba(239, 68, 68, 0.5);
            transform: translateY(-2px);
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">

    <div class="background"></div>
    
    <header class="app-header">
        <div class="header-content">
            <div class="nav-buttons">
                <a href="../" id="showOverlayModeLink" class="header-button">OBSオーバーレイ</a>
                <a href="./" id="showTrackerModeLink" class="header-button active">戦績トラッカー</a>
                <a href="../match-history.html" class="header-button">マッチ履歴</a>
                <a href="../skins-database.html" class="header-button">スキンDB</a>
                <a href="../leaderboard.html" class="header-button">ランキング</a>
            </div>
            
            <!-- ハンバーガーメニューボタン -->
            <div class="hamburger-menu" id="hamburgerMenu">
                <div class="hamburger-line"></div>
                <div class="hamburger-line"></div>
                <div class="hamburger-line"></div>
            </div>
            
            <div class="author-section">
                <p class="author-text">Project by にど寝</p>
                <img src="../assets/images/nidone.png" alt="製作者アバター" class="author-avatar">
            </div>
        </div>
        
        <!-- モバイル用ナビゲーション -->
        <div class="mobile-nav" id="mobileNav">
            <div class="mobile-nav-buttons">
                <a href="../" class="header-button">OBSオーバーレイ</a>
                <a href="./" class="header-button active">戦績トラッカー</a>
                <a href="../match-history.html" class="header-button">マッチ履歴</a>
                <a href="../skins-database.html" class="header-button">スキンDB</a>
                <a href="../leaderboard.html" class="header-button">ランキング</a>
            </div>
        </div>
    </header>

    <div class="max-w-5xl mx-auto mt-4">

        <!-- Page Title -->
        <header class="text-center mb-6 sm:mb-8">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-red-500 tracking-wider">VALORANT Tracker</h1>
            <p class="text-gray-400 mt-2 text-sm sm:text-base">今シーズンのコンペティティブ戦績を分析します</p>
        </header>

        <!-- Search Form -->
        <div class="mb-6 sm:mb-8 p-4 sm:p-6 bg-gray-800 rounded-xl shadow-lg">
            <div class="flex flex-col sm:flex-row gap-3 sm:gap-4">
                <input type="text" id="gameNameInput" class="flex-grow bg-gray-700 text-white placeholder-gray-400 border-2 border-gray-600 rounded-lg px-3 sm:px-4 py-2 sm:py-3 focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-red-500 text-sm sm:text-base" placeholder="ゲーム名 (例: TenZ)">
                <input type="text" id="tagLineInput" class="flex-grow bg-gray-700 text-white placeholder-gray-400 border-2 border-gray-600 rounded-lg px-3 sm:px-4 py-2 sm:py-3 focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-red-500 text-sm sm:text-base" placeholder="タグライン (例: 1234)">
                <button id="searchButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 sm:py-3 px-4 sm:px-6 rounded-lg transition-colors duration-300 flex items-center justify-center text-sm sm:text-base">
                    <svg id="searchIcon" class="w-4 h-4 sm:w-5 sm:h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                    <svg id="loadingIcon" class="animate-spin -ml-1 mr-3 h-4 w-4 sm:h-5 sm:w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span id="buttonText">検索</span>
                </button>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="hidden space-y-6 sm:space-y-8">
            <!-- Player Info and Score -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 sm:gap-8">
                <div class="lg:col-span-1 bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg flex flex-col items-center justify-center text-center">
                    <h2 id="playerName" class="text-xl sm:text-2xl font-bold"></h2>
                    <p id="playerTag" class="text-gray-400 text-sm sm:text-base"></p>
                    <div id="playerRankSection" class="mt-4"></div>
                </div>
                <div class="lg:col-span-2 bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg">
                    <div class="flex flex-col lg:flex-row gap-4 sm:gap-6 items-center lg:items-start w-full">
                        <!-- 左側: Tracker Score と Tier -->
                        <div class="flex flex-col items-center text-center p-2 lg:w-1/3 w-full">
                            <h3 class="text-lg sm:text-xl font-semibold text-gray-300 mb-1">Tracker Score</h3>
                            <p id="trackerScore" class="text-5xl sm:text-7xl font-bold text-red-500 leading-tight">---</p>
                            <div id="trackerTier" class="mt-3 text-xl sm:text-2xl font-bold px-6 sm:px-8 py-2 rounded-full shadow-md">--</div>
                        </div>

                        <!-- 右側: 詳細統計カード群 -->
                        <div id="additionalStatsContainer" class="grid grid-cols-2 gap-2 sm:gap-3 md:gap-4 lg:w-2/3 w-full mt-4 lg:mt-0">
                            <!-- 平均ACSカード -->
                            <div id="statCardAvgAcs" class="p-2 sm:p-3 rounded-lg shadow-md flex flex-col items-center justify-center">
                                <span class="block text-xs font-medium mb-1">平均ACS</span>
                                <span id="statAvgAcs" class="block font-semibold text-lg sm:text-xl">N/A</span>
                                <span id="statTierAvgAcs" class="block text-xs sm:text-sm font-bold mt-1">--</span>
                            </div>
                            <!-- 平均K/Dカード -->
                            <div id="statCardAvgKd" class="p-2 sm:p-3 rounded-lg shadow-md flex flex-col items-center justify-center">
                                <span class="block text-xs font-medium mb-1">平均K/D</span>
                                <span id="statAvgKd" class="block font-semibold text-lg sm:text-xl">N/A</span>
                                <span id="statTierAvgKd" class="block text-xs sm:text-sm font-bold mt-1">--</span>
                            </div>
                            <!-- 勝率カード -->
                            <div id="statCardWinRate" class="p-2 sm:p-3 rounded-lg shadow-md flex flex-col items-center justify-center">
                                <span class="block text-xs font-medium mb-1">勝率</span>
                                <span id="statWinRate" class="block font-semibold text-lg sm:text-xl">N/A</span>
                                <span id="statTierWinRate" class="block text-xs sm:text-sm font-bold mt-1">--</span>
                            </div>
                            <!-- 平均DDΔカード -->
                            <div id="statCardAvgDdDelta" class="p-2 sm:p-3 rounded-lg shadow-md flex flex-col items-center justify-center">
                                <span class="block text-xs font-medium mb-1">平均DDΔ</span>
                                <span id="statAvgDdDelta" class="block font-semibold text-lg sm:text-xl">N/A</span>
                                <span id="statTierAvgDdDelta" class="block text-xs sm:text-sm font-bold mt-1">--</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ACS Chart -->
            <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg">
                <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-3 sm:gap-0">
                    <h3 id="chartTitle" class="text-lg sm:text-xl font-bold">ACS (Average Combat Score) 推移</h3>
                    <div id="chartTypeSelector" class="flex flex-wrap gap-1 sm:gap-2">
                        <button data-type="acs" class="chart-type-button bg-red-500 text-white px-2 sm:px-3 py-1 rounded-md text-xs sm:text-sm">ACS</button>
                        <button data-type="kd" class="chart-type-button bg-gray-600 hover:bg-gray-500 text-white px-2 sm:px-3 py-1 rounded-md text-xs sm:text-sm">K/D</button>
                        <button data-type="ddDelta" class="chart-type-button bg-gray-600 hover:bg-gray-500 text-white px-2 sm:px-3 py-1 rounded-md text-xs sm:text-sm">DDΔ</button>
                        <button data-type="hs" class="chart-type-button bg-gray-600 hover:bg-gray-500 text-white px-2 sm:px-3 py-1 rounded-md text-xs sm:text-sm">HS%</button>
                    </div>
                </div>
                <canvas id="statsChart"></canvas>
            </div>

            <!-- Match History -->
            <div class="bg-gray-800 rounded-xl shadow-lg overflow-hidden">
                <h3 class="text-lg sm:text-xl font-bold p-4 sm:p-6">今シーズンの戦績 (コンペティティブ)</h3>
                
                <!-- デスクトップ用テーブル -->
                <div class="match-table-desktop overflow-x-auto">
                    <table class="w-full text-left">
                        <thead class="bg-gray-700 text-gray-300 uppercase text-sm">
                            <tr>
                                <th class="p-4">マップ</th>
                                <th class="p-4">エージェント</th>
                                <th class="p-4">ランク</th>
                                <th class="p-4">結果</th>
                                <th class="p-4">KDA</th>
                                <th class="p-4">K/D</th>
                                <th class="p-4">HS%</th>
                                <th class="p-4">ACS</th>
                            </tr>
                        </thead>
                        <tbody id="matchHistoryBody" class="divide-y divide-gray-700">
                            <!-- Match data will be inserted here -->
                        </tbody>
                    </table>
                </div>

                <!-- モバイル用カード -->
                <div id="matchHistoryMobile" class="match-cards-mobile p-4 space-y-4">
                    <!-- Match cards will be inserted here -->
                </div>
            </div>
        </div>
    </div>



    <!-- Error Modal -->
    <div id="errorModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-4 sm:p-6 max-w-sm w-full text-center">
            <div class="mx-auto flex items-center justify-center h-10 w-10 sm:h-12 sm:w-12 rounded-full bg-red-200 mb-4">
                <svg class="h-5 w-5 sm:h-6 sm:w-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
            </div>
            <h3 class="text-base sm:text-lg font-medium text-white">エラーが発生しました</h3>
            <div class="mt-2 text-xs sm:text-sm text-gray-400">
                <p id="errorMessage"></p>
            </div>
            <div class="mt-4">
                <button id="closeModalButton" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm sm:text-base">
                    閉じる
                </button>
            </div>
        </div>
    </div>

    <script src="../config.js"></script>
    <script>
        // ハンバーガーメニューの動作（完全統一版）
        function initializeHamburgerMenu() {
            const hamburgerMenu = document.getElementById('hamburgerMenu');
            const mobileNav = document.getElementById('mobileNav');
            
            if (!hamburgerMenu || !mobileNav) {
                console.warn('ハンバーガーメニューまたはモバイルナビが見つかりません');
                return;
            }
            
            // ハンバーガーメニューのクリックイベント
            hamburgerMenu.addEventListener('click', function(event) {
                event.stopPropagation();
                hamburgerMenu.classList.toggle('active');
                mobileNav.classList.toggle('active');
                
                // アクセシビリティのためのaria属性を更新
                const isActive = hamburgerMenu.classList.contains('active');
                hamburgerMenu.setAttribute('aria-expanded', isActive);
                mobileNav.setAttribute('aria-hidden', !isActive);
            });
            
            // モバイルナビのリンクをクリックしたときにメニューを閉じる
            const mobileNavLinks = mobileNav.querySelectorAll('.header-button');
            mobileNavLinks.forEach(link => {
                link.addEventListener('click', () => {
                    closeHamburgerMenu();
                });
            });
            
            // 画面外をクリックしたときにメニューを閉じる
            document.addEventListener('click', function(event) {
                if (!hamburgerMenu.contains(event.target) && 
                    !mobileNav.contains(event.target) && 
                    mobileNav.classList.contains('active')) {
                    closeHamburgerMenu();
                }
            });
            
            // ESCキーでメニューを閉じる
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && mobileNav.classList.contains('active')) {
                    closeHamburgerMenu();
                }
            });
            
            // ウィンドウリサイズ時にメニューを閉じる（デスクトップビューに戻った場合）
            window.addEventListener('resize', function() {
                if (window.innerWidth > 768 && mobileNav.classList.contains('active')) {
                    closeHamburgerMenu();
                }
            });
            
            // メニューを閉じる共通関数
            function closeHamburgerMenu() {
                hamburgerMenu.classList.remove('active');
                mobileNav.classList.remove('active');
                hamburgerMenu.setAttribute('aria-expanded', false);
                mobileNav.setAttribute('aria-hidden', true);
            }
            
            // 初期状態のaria属性を設定
            hamburgerMenu.setAttribute('aria-expanded', false);
            hamburgerMenu.setAttribute('aria-label', 'メニューを開く');
            mobileNav.setAttribute('aria-hidden', true);
            
            console.log('ハンバーガーメニューが正常に初期化されました');
        }

        // ページ読み込み時にハンバーガーメニューを初期化
        document.addEventListener('DOMContentLoaded', function() {
            initializeHamburgerMenu();
        });
    </script>
    <script type="module">
        // --- ★★★ 重要 ★★★ ---
        // Riot Developer Portal (https://developer.riotgames.com/) から
        // 新しい開発用APIキーを取得してください。
        // プロジェクトルートに config.js ファイルを作成し、
        // const RIOT_API_KEY = "YOUR_RIOT_API_KEY_HERE"; の形式でキーを記述してください。
        // このキーは24時間で有効期限が切れるため、定期的な更新が必要です。
        // 重要: config.js ファイルは .gitignore に追加して、リポジトリに含めないようにしてください。
        const API_KEY = RIOT_API_KEY; 
        console.log("API Key loaded:", API_KEY ? `Yes, length: ${API_KEY.length}` : "No, API_KEY is not set or empty");
        
        // --- CONFIGURATION ---
        const RAW_MATCH_COUNT_TO_FETCH = 30; // シーズン判定のために取得する試合数 (APIのsize上限も考慮)
        // const MATCH_COUNT = 5; // 表示する試合数はシーズンフィルタリング後に決定されるため、この定数は直接使わなくなる

        // --- DOM ELEMENTS ---
        const gameNameInput = document.getElementById('gameNameInput');
        const tagLineInput = document.getElementById('tagLineInput');
        const searchButton = document.getElementById('searchButton');
        const searchIcon = document.getElementById('searchIcon');
        const loadingIcon = document.getElementById('loadingIcon');
        const buttonText = document.getElementById('buttonText');
        const resultsSection = document.getElementById('resultsSection');
        const errorModal = document.getElementById('errorModal');
        const errorMessage = document.getElementById('errorMessage');
        const closeModalButton = document.getElementById('closeModalButton');
        
        let statsChartInstance = null;
        let currentChartType = 'acs';
        let lastProcessedMatchHistory = [];

        // --- EVENT LISTENERS ---
        searchButton.addEventListener('click', handleSearch);
        gameNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSearch();
            }
        });
        tagLineInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSearch();
            }
        });
        closeModalButton.addEventListener('click', () => {
            errorModal.classList.add('hidden');
        });

        // グラフタイプ選択ボタンのイベントリスナー設定
        document.addEventListener('DOMContentLoaded', () => {
            const chartTypeButtons = document.querySelectorAll('.chart-type-button');
            chartTypeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const type = button.dataset.type;
                    if (type === currentChartType && statsChartInstance) return; // 同じタイプで既にグラフ表示中なら何もしない

                    currentChartType = type;
                    updateStatsChart();

                    // ボタンのスタイル更新
                    chartTypeButtons.forEach(btn => {
                        btn.classList.remove('bg-red-500');
                        btn.classList.add('bg-gray-600', 'hover:bg-gray-500');
                    });
                    button.classList.add('bg-red-500');
                    button.classList.remove('bg-gray-600', 'hover:bg-gray-500');
                });
            });
        });

        // --- MAIN FUNCTION ---
        async function handleSearch() {
            // APIキーが設定されているかチェックします。
            if (!API_KEY || API_KEY === "YOUR_RIOT_API_KEY_HERE") {
                showError('APIキーが設定されていません。config.js ファイルに有効な Riot API キーを記述し、コメントの指示に従って更新してください。');
                return;
            }
            const gameName = gameNameInput.value.trim();
            const tagLine = tagLineInput.value.trim();
            if (!gameName || !tagLine) {
                showError('ゲーム名とタグラインの両方を入力してください。(#は不要です)');
                return;
            }

            setLoadingState(true);
            resultsSection.classList.add('hidden');

            try {
                console.log(`[検索開始] プレイヤー: ${gameName}#${tagLine}`);
                
                // 1. Get Account Data (PUUID and Region) from Riot ID
                console.log('[ステップ1] アカウント情報を取得中...');
                const accountData = await getPuuid(gameName, tagLine);
                if (!accountData || !accountData.puuid || !accountData.region) {
                    throw new Error('アカウント情報の取得に失敗しました。プレイヤー名とタグラインを確認してください。');
                }
                const puuid = accountData.puuid;
                const userRegion = accountData.region;
                console.log(`[ステップ1完了] 地域: ${userRegion}, PUUID: ${puuid.substring(0, 8)}...`);

                // 2. Get recent competitive match IDs
                console.log('[ステップ2] マッチID一覧を取得中...');
                const matchIds = await getMatchIds(gameName, tagLine, userRegion);
                if (matchIds.length === 0) {
                    showError('このプレイヤーの直近のコンペティティブマッチが見つかりませんでした。アンレートやカスタムゲームのみプレイしている可能性があります。');
                    setLoadingState(false);
                    return;
                }
                console.log(`[ステップ2完了] ${matchIds.length}件のマッチIDを取得`);

                // 3. Get details for each match  
                console.log('[ステップ3] マッチ詳細データを取得中...');
                const matchDetails = await getMatchDetails(matchIds, userRegion);
                console.log(`[ステップ3完了] ${matchDetails.length}件のマッチ詳細を取得`);

                // 4. Get MMR Data (並行実行)
                console.log('[ステップ4] MMRデータを取得中...');
                const [mmrData, mmrHistory] = await Promise.allSettled([
                    getMmrData(userRegion, gameName, tagLine),
                    getMmrHistory(userRegion, puuid)
                ]);
                
                const finalMmrData = mmrData.status === 'fulfilled' ? mmrData.value : null;
                const finalMmrHistory = mmrHistory.status === 'fulfilled' ? mmrHistory.value : [];
                
                if (mmrData.status === 'rejected') {
                    console.warn('[警告] MMRデータの取得に失敗:', mmrData.reason);
                }
                if (mmrHistory.status === 'rejected') {
                    console.warn('[警告] MMR履歴の取得に失敗:', mmrHistory.reason);
                }
                console.log('[ステップ4完了] MMRデータ取得完了');

                // 5. Process and render data
                console.log('[ステップ5] データ処理中...');
                const processedMatchHistory = processMatchData(matchDetails, puuid);
                if (processedMatchHistory.length === 0) {
                    showError('今シーズンのコンペティティブマッチデータがありません。前のシーズンのデータまたはプレイヤー情報が古い可能性があります。');
                    setLoadingState(false);
                    return;
                }
                
                renderResults(processedMatchHistory, gameName, tagLine, accountData, finalMmrData, finalMmrHistory);
                console.log(`[検索完了] ${processedMatchHistory.length}件のマッチデータを表示`);
                
                resultsSection.classList.remove('hidden');

            } catch (error) {
                console.error("[検索エラー] 詳細:", error);
                
                // エラーの種類に応じてより具体的なメッセージを表示
                let userFriendlyMessage = error.message || 'データの取得中に不明なエラーが発生しました。';
                
                if (error.message.includes('ネットワーク')) {
                    userFriendlyMessage += '\n\n• インターネット接続を確認してください\n• VPNを使用している場合は無効にしてみてください';
                } else if (error.message.includes('タイムアウト')) {
                    userFriendlyMessage += '\n\n• しばらく時間をおいてから再試行してください\n• ネットワーク速度が遅い可能性があります';
                } else if (error.message.includes('レート制限')) {
                    userFriendlyMessage += '\n\n• 短時間に多くのリクエストが送信されました\n• 1-2分待ってから再試行してください';
                } else if (error.message.includes('APIキー')) {
                    userFriendlyMessage += '\n\n• config.jsファイルのAPIキーを確認してください\n• 新しいAPIキーが必要な場合があります';
                } else if (error.message.includes('プレイヤーが見つかりません')) {
                    userFriendlyMessage += '\n\n• ゲーム名とタグラインの入力内容を確認してください\n• 大文字小文字や特殊文字に注意してください';
                }
                
                showError(userFriendlyMessage);
            } finally {
                setLoadingState(false);
            }
        }

        // --- API CALLS ---
        async function apiFetch(url, isHenrikDev = true, retryCount = 3) {
            let requestUrl = url;
            if (isHenrikDev && API_KEY) {
                // URLに既にクエリパラメータがあるか確認
                requestUrl += (url.includes('?') ? '&' : '?') + `api_key=${API_KEY}`;
            }

            const headers = {};
            
            for (let attempt = 1; attempt <= retryCount; attempt++) {
                try {
                    console.log(`[API] リクエスト送信中 (試行 ${attempt}/${retryCount}): ${requestUrl}`);
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15秒タイムアウト

                    const response = await fetch(requestUrl, {
                        headers: headers,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ message: "レスポンス解析エラー" }));
                        const errorMessageDetail = errorData.errors && errorData.errors[0] && errorData.errors[0].message 
                                                ? errorData.errors[0].message 
                                                : (errorData.message || `HTTP ${response.status}`);

                        if (response.status === 401) {
                            throw new Error(`APIキーが無効か期限切れです。新しいAPIキーを取得してください。詳細: ${errorMessageDetail}`);
                        }
                        if (response.status === 403) {
                            throw new Error(`アクセスが拒否されました。APIキーの権限を確認してください。詳細: ${errorMessageDetail}`);
                        }
                        if (response.status === 404) {
                            throw new Error(`プレイヤーが見つかりません。ゲーム名とタグラインを確認してください。詳細: ${errorMessageDetail}`);
                        }
                        if (response.status === 429) {
                            if (attempt < retryCount) {
                                console.warn(`[API] レート制限検出。${2 ** attempt}秒後にリトライします...`);
                                await new Promise(resolve => setTimeout(resolve, 2000 * (2 ** (attempt - 1))));
                                continue;
                            }
                            throw new Error(`APIのレート制限に達しました。しばらく時間をおいてから再試行してください。詳細: ${errorMessageDetail}`);
                        }
                        if (response.status >= 500) {
                            if (attempt < retryCount) {
                                console.warn(`[API] サーバーエラー (${response.status})。${2 * attempt}秒後にリトライします...`);
                                await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
                                continue;
                            }
                            throw new Error(`APIサーバーエラーが発生しました。しばらく時間をおいてから再試行してください。詳細: ${errorMessageDetail}`);
                        }
                        throw new Error(`API呼び出しエラー: ${response.status} - ${errorMessageDetail}`);
                    }

                    console.log(`[API] リクエスト成功 (試行 ${attempt}/${retryCount})`);
                    return await response.json();

                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.warn(`[API] タイムアウト (試行 ${attempt}/${retryCount})`);
                        if (attempt < retryCount) {
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                            continue;
                        }
                        throw new Error('APIリクエストがタイムアウトしました。ネットワーク接続を確認してください。');
                    }
                    
                    if (error.message.includes('fetch')) {
                        console.warn(`[API] ネットワークエラー (試行 ${attempt}/${retryCount}): ${error.message}`);
                        if (attempt < retryCount) {
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                            continue;
                        }
                        throw new Error('ネットワークエラーが発生しました。インターネット接続を確認してください。');
                    }
                    
                    // APIエラー系は即座に投げる（リトライしない）
                    if (error.message.includes('APIキー') || error.message.includes('アクセスが拒否') || error.message.includes('プレイヤーが見つかりません')) {
                        throw error;
                    }
                    
                    console.error(`[API] 予期しないエラー (試行 ${attempt}/${retryCount}):`, error);
                    if (attempt === retryCount) {
                        throw new Error(`データの取得に失敗しました: ${error.message}`);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
        }

        async function getPuuid(gameName, tagLine) {
            const baseUrl = `https://api.henrikdev.xyz/valorant/v2/account/${encodeURIComponent(gameName)}/${encodeURIComponent(tagLine)}`;
            const data = await apiFetch(baseUrl); 
            if (!data.status || data.status !== 200 || !data.data || !data.data.puuid || !data.data.region) {
                throw new Error('PUUIDまたはリージョンの取得に失敗しました (HenrikDev API)。レスポンス: ' + JSON.stringify(data));
            }

            // ★★★ デバッグ用ログを削除 ★★★
            // console.log("API response for card data:", JSON.stringify(data.data.card, null, 2));

            // アイコン設定ロジックを削除
            // let iconUrl = 'https://placehold.co/96x96/1f2937/7f1d1d?text=?'; // デフォルト
            // if (data.data.card) {
            //     if (data.data.card.wide) {
            //         iconUrl = data.data.card.wide;
            //     } else if (data.data.card.large) {
            //         iconUrl = data.data.card.large;
            //     } else if (data.data.card.small) {
            //         iconUrl = data.data.card.small;
            //     }
            // }
            // document.getElementById('playerIcon').src = iconUrl;
            return data.data; // PUUIDだけでなく、リージョン情報も含むdata.data全体を返す
        }

        async function getMatchIds(gameName, tagLine, region) {
            // platform 'pc' をハードコード。REGION_MATCHの代わりに引数で受け取ったregionを使用
            const baseUrl = `https://api.henrikdev.xyz/valorant/v4/matches/${region}/pc/${encodeURIComponent(gameName)}/${encodeURIComponent(tagLine)}`;
            // filter=competitive を mode=competitive に修正
            // size を RAW_MATCH_COUNT_TO_FETCH に変更
            const urlWithParams = `${baseUrl}?mode=competitive&size=${RAW_MATCH_COUNT_TO_FETCH}`;
            const data = await apiFetch(urlWithParams);
            if (!data.status || data.status !== 200 || !data.data) {
                throw new Error('マッチIDの取得に失敗しました (HenrikDev API)。レスポンス: ' + JSON.stringify(data));
            }
            return data.data.map(match => match.metadata.match_id);
        }

        async function getMatchDetails(matchIds, region) {
            const matchDetailsArray = [];
            for (const matchId of matchIds) {
                // v2からv4に変更し、regionをパスパラメータに追加
                const url = `https://api.henrikdev.xyz/valorant/v4/match/${region}/${matchId}`;
                try {
            const data = await apiFetch(url);
                    if (!data.status || data.status !== 200 || !data.data) {
                        console.warn(`マッチ詳細の取得に失敗 (ID: ${matchId}): `, data);
                        continue; // エラーがあっても処理を続行し、取得できたマッチのみを処理
                    }
                    matchDetailsArray.push(data.data);
                } catch (error) {
                    console.warn(`マッチ詳細の取得中にエラー (ID: ${matchId}): `, error);
                    // エラーモーダルはhandleSearchのcatchでまとめて表示するため、ここでは個別のエラー表示はしない
                }
            }
            if (matchDetailsArray.length === 0 && matchIds.length > 0) {
                 throw new Error('すべてのマッチ詳細データの取得に失敗しました。');
            }
            return matchDetailsArray;
        }

        async function getMmrData(region, gameName, tagLine) {
            const baseUrl = `https://api.henrikdev.xyz/valorant/v2/mmr/${region}/${encodeURIComponent(gameName)}/${encodeURIComponent(tagLine)}`;
            // PUUIDベースのエンドポイントも利用可能:
            // const baseUrl = `https://api.henrikdev.xyz/valorant/v2/by-puuid/mmr/${region}/${puuid}`;
            const data = await apiFetch(baseUrl);
            // デバッグ用ログはコメントアウトまたは削除
            // console.log("getMmrData API response:", JSON.stringify(data, null, 2)); 
            if (!data.status || data.status !== 200 || !data.data) {
                console.warn('MMRデータの取得に失敗しました (HenrikDev API)。レスポンス: ' + JSON.stringify(data));
                return null; // エラーの場合はnullを返すなどして後続処理で対応
            }
            // console.log("MMR Data fetched (data.data part only):", JSON.stringify(data.data, null, 2)); 
            return data.data;
        }

        async function getMmrHistory(region, puuid) {
            const baseUrl = `https://api.henrikdev.xyz/valorant/v1/by-puuid/mmr-history/${region}/${puuid}`;
            try {
                const data = await apiFetch(baseUrl);
                if (!data.status || data.status !== 200 || !data.data) {
                    console.warn('MMR履歴の取得に失敗しました (HenrikDev API)。レスポンス: ' + JSON.stringify(data));
                    return []; // エラーの場合は空配列を返す
                }
                console.log("MMR History fetched:", JSON.stringify(data.data, null, 2));
                return data.data; // MMR履歴データの配列
            } catch (error) {
                console.error("Error fetching MMR history:", error);
                showError('MMR履歴データの取得中にエラーが発生しました。詳細はコンソールを確認してください。');
                return []; // エラーの場合は空配列を返す
            }
        }

        // --- DATA PROCESSING ---
        function processMatchData(matches, puuid) {
            console.log("processMatchData received matches (before season filter):", JSON.stringify(matches, null, 2));
            console.log("processMatchData received puuid:", puuid);

            if (!matches || matches.length === 0) {
                return [];
            }

            // 最新の試合から現在のシーズンIDを特定
            let currentSeasonId = null;
            for (const match of matches) { // まず有効なシーズンIDを持つ最初のマッチを探す
                if (match && match.metadata && match.metadata.season && match.metadata.season.id) {
                    currentSeasonId = match.metadata.season.id;
                    break;
                }
            }

            if (!currentSeasonId) {
                console.warn("Could not determine current season ID from fetched matches. Displaying all fetched competitive matches.");
                // シーズンIDが特定できない場合は、取得した全コンペ試合をそのまま処理 (従来通りのフォールバック)
            } else {
                console.log("Determined current season ID:", currentSeasonId);
            }

            const processedMatches = matches.map(match => {
                console.log("Processing match:", JSON.stringify(match, null, 2)); 

                if (!match || !match.metadata || !match.players || !match.teams || !match.rounds) {
                    console.warn("Skipping match due to missing fundamental data structure (metadata, players, teams, or rounds):", match);
                    return null;
                }

                // ★ 変更: シーズンIDによるフィルタリング (currentSeasonIdが特定できた場合のみ)
                if (currentSeasonId && (!match.metadata.season || match.metadata.season.id !== currentSeasonId)) {
                    console.log(`Skipping match from different season: match season_id=${match.metadata.season ? match.metadata.season.id : 'N/A'}, current_season_id=${currentSeasonId}`);
                    return null;
                }
                
                // ★ 追加: ゲームモードがコンペティティブであるかを確認 (これは残す)
                if (!match.metadata.queue || (match.metadata.queue.id !== 'competitive' && match.metadata.queue.name !== 'Competitive')) {
                    console.log(`Skipping non-competitive match: queue.id=${match.metadata.queue.id}, queue.name=${match.metadata.queue.name}`);
                    return null;
                }

                const player = match.players.find(p => p.puuid === puuid);
                // console.log("Found player in match:", JSON.stringify(player, null, 2)); 

                if (!player || !player.stats || !player.agent) { 
                    console.warn("Player not found, or player missing stats/agent in match:", match, "for puuid:", puuid);
                    return null;
                }
                 // ★★★ KAST, DDΔ調査用ログを追加 ★★★
                // console.log(`Player stats for match ${match.metadata.match_id}:`, JSON.stringify(player.stats, null, 2)); // 確認したのでコメントアウト

                // ★ デバッグログ: player.tier の内容を確認
                console.log(`[Debug] Match ${match.metadata.match_id} - Raw player.tier from match details:`, player.tier);

                const playerTeamData = match.teams.find(t => t.team_id.toLowerCase() === player.team_id.toLowerCase());
                console.log("Found playerTeamData:", JSON.stringify(playerTeamData, null, 2)); 

                if (!playerTeamData || typeof playerTeamData.won !== 'boolean' || !playerTeamData.rounds) {
                     console.warn("Player team data not found or incomplete:", match, "for team_id:", player.team_id);
                    return null;
                }
                const won = playerTeamData.won;
                const roundsWon = playerTeamData.rounds.won;
                const roundsLost = playerTeamData.rounds.lost;

                const totalShots = (player.stats.headshots || 0) + (player.stats.bodyshots || 0) + (player.stats.legshots || 0);
                const hsPercentage = totalShots > 0
                    ? (((player.stats.headshots || 0) / totalShots) * 100).toFixed(1)
                    : "0.0";
                
                const roundsPlayed = match.rounds.length;
                const acs = (roundsPlayed > 0 && player.stats && player.stats.score !== undefined)
                    ? Math.round(player.stats.score / roundsPlayed)
                    : 0;
                // console.log(`ACS calculation: score=${player.stats.score}, roundsPlayed=${roundsPlayed}, acs=${acs}`); 
                
                // KAST, Damage Dealt, Damage Received の取得試行
                const damageDealtValue = (player.stats.damage && typeof player.stats.damage.dealt === 'number') ? player.stats.damage.dealt : 0;
                const damageReceivedValue = (player.stats.damage && typeof player.stats.damage.received === 'number') ? player.stats.damage.received : 0;

                let agentIconUrl = 'https://placehold.co/32x32/1f2937/7f1d1d?text=?'; 
                if (player.agent && player.agent.name) {
                    const rawAgentName = player.agent.name;
                    const formattedAgentName = rawAgentName.toLowerCase().replace(/[^a-z0-9]/gi, '');
                    agentIconUrl = `../assets/images/agents/${formattedAgentName}.png`;
                }

                const rankNameMapping = {
                    "Iron 1": "アイアン1",
                    "Iron 2": "アイアン2",
                    "Iron 3": "アイアン3",
                    "Bronze 1": "ブロンズ1",
                    "Bronze 2": "ブロンズ2",
                    "Bronze 3": "ブロンズ3",
                    "Silver 1": "シルバー1",
                    "Silver 2": "シルバー2",
                    "Silver 3": "シルバー3",
                    "Gold 1": "ゴールド1",
                    "Gold 2": "ゴールド2",
                    "Gold 3": "ゴールド3",
                    "Platinum 1": "プラチナ1",
                    "Platinum 2": "プラチナ2",
                    "Platinum 3": "プラチナ3",
                    "Diamond 1": "ダイヤ1",
                    "Diamond 2": "ダイヤ2",
                    "Diamond 3": "ダイヤ3",
                    "Ascendant 1": "アセンダント1",
                    "Ascendant 2": "アセンダント2",
                    "Ascendant 3": "アセンダント3",
                    "Immortal 1": "イモータル1",
                    "Immortal 2": "イモータル2",
                    "Immortal 3": "イモータル3",
                    "Radiant": "レディアント",
                    "Unranked": "ランクなし"
                };

                let rankIconUrl = 'https://placehold.co/48x48/1f2937/7f1d1d?text=R';
                let apiRankName = player.tier && player.tier.name ? player.tier.name : "Unranked";
                let displayRankName = apiRankName; // This will be the name shown alongside the icon in the match row

                // ★ デバッグログ: 解決されたランク名と、マッピング試行前のアイコンURL
                console.log(`[Debug] Match ${match.metadata.match_id} - Resolved apiRankName for icon: ${apiRankName}`);
                console.log(`[Debug] Match ${match.metadata.match_id} - Initial rankIconUrl for player ${player.game_name}: ${rankIconUrl}`);

                if (rankNameMapping[apiRankName]) {
                    const japaneseFileName = rankNameMapping[apiRankName];
                    rankIconUrl = `../assets/images/ranks/${japaneseFileName}.png`;
                    // ★ デバッグログ: マッピング成功時のアイコンURL
                    console.log(`[Debug] Match ${match.metadata.match_id} - Rank Mapped for player ${player.game_name}. New rankIconUrl: ${rankIconUrl}`);
                } else {
                    // マッピングに失敗した場合
                    console.warn(`[Debug] Match ${match.metadata.match_id} - Rank name "${apiRankName}" for player ${player.game_name} not found in rankNameMapping or "Unranked" mapping issue. Using placeholder. Final rankIconUrl: ${rankIconUrl}`);
                }

                const rankPoints = "-- RR"; // これは renderResults で MMR 履歴とマージして上書きされる

                return {
                    matchId: match.metadata.match_id, // ★ renderResults で MMR 履歴と紐付けるために match_id を追加
                    map: match.metadata.map ? match.metadata.map.name : '不明なマップ',
                    agentName: player.agent.name || '不明なエージェント',
                    agentIcon: agentIconUrl,
                    result: won ? '勝利' : '敗北',
                    resultBoolean: won, // 勝率計算用にbooleanも保持
                    resultColor: won ? 'text-green-400' : 'text-red-400',
                    score: `${roundsWon} - ${roundsLost}`,
                    kills: player.stats.kills || 0, // K/D計算用に保持
                    deaths: player.stats.deaths || 0, // K/D計算用に保持
                    kda: `${player.stats.kills || 0} / ${player.stats.deaths || 0} / ${player.stats.assists || 0}`,
                    kd: (player.stats.deaths === 0 ? (player.stats.kills || 0) : ((player.stats.kills || 0) / player.stats.deaths)).toFixed(2),
                    hs: hsPercentage,
                    acs: acs,
                    rankName: displayRankName, 
                    rankIcon: rankIconUrl,
                    rankPoints: rankPoints, // 初期値は "-- RR"
                    seasonId: match.metadata.season ? match.metadata.season.id : null, 
                    damageDealt: damageDealtValue, // 与ダメージ
                    damageReceived: damageReceivedValue, // 被ダメージ
                    roundsPlayed: roundsPlayed // ラウンド数
                };
            }).filter(Boolean); 

            console.log("processMatchData returning (after season filter):", JSON.stringify(processedMatches, null, 2));
            return processedMatches;
        }

        // --- RENDERING ---
        function renderResults(processedMatchHistory, name, tag, accountData, mmrData, mmrHistory) {
            // Player Info
            document.getElementById('playerName').textContent = name;
            document.getElementById('playerTag').textContent = `#${tag}`;
            
            lastProcessedMatchHistory = processedMatchHistory;

            // デバッグ用ログはコメントアウトまたは削除
            // console.log("renderResults received mmrData:", JSON.stringify(mmrData, null, 2));
            // if (mmrData) {
            //     console.log("mmrData.current_data.currenttierpatched in renderResults:", mmrData.current_data ? mmrData.current_data.currenttierpatched : 'N/A');
            //     console.log("mmrData.current_data.images in renderResults:", mmrData.current_data ? mmrData.current_data.images : 'N/A');
            //     console.log("mmrData.current_data.ranking_in_tier in renderResults:", mmrData.current_data ? mmrData.current_data.ranking_in_tier : 'N/A');
            //     console.log("mmrData.current_data.mmr_change_to_last_game in renderResults:", mmrData.current_data ? mmrData.current_data.mmr_change_to_last_game : 'N/A');
            // }

            const playerRankSection = document.getElementById('playerRankSection');
            playerRankSection.innerHTML = ''; // 初期化

            // mmrData と mmrData.current_data の存在をチェックし、さらに currenttierpatched もチェック
            if (playerRankSection && mmrData && mmrData.current_data && mmrData.current_data.currenttierpatched) {
                const currentRankName = mmrData.current_data.currenttierpatched;
                const currentRR = mmrData.current_data.ranking_in_tier || 0;
                const mmrChange = mmrData.current_data.mmr_change_to_last_game;
                let rankIconFromMmr = 'https://placehold.co/80x80/1f2937/7f1d1d?text=R'; // デフォルト

                if (mmrData.current_data.images && mmrData.current_data.images.large) {
                    rankIconFromMmr = mmrData.current_data.images.large;
                } else {
                     // images.largeがない場合でも、rankNameMapping を使ってローカルアセットを参照する試みは残す
                     if (rankNameMapping[currentRankName]) {
                         const japaneseFileName = rankNameMapping[currentRankName];
                         rankIconFromMmr = `../assets/images/ranks/${japaneseFileName}.png`;
                     }
                }
                
                let lastMatchRRChangeString = "";
                if (mmrChange !== undefined && mmrChange !== null) {
                    const sign = mmrChange >= 0 ? '+' : '';
                    lastMatchRRChangeString = `<span class="text-sm ${mmrChange >= 0 ? 'text-green-400' : 'text-red-400'} font-semibold">前回のマッチ: ${sign}${mmrChange} RR</span>`;
                }

                playerRankSection.innerHTML = `
                    <div class="flex flex-col items-center justify-center mt-1">
                        <img src="${rankIconFromMmr}" alt="${currentRankName}" class="w-20 h-20 object-contain mb-2" onerror="this.onerror=null; this.src='https://placehold.co/80x80/1f2937/7f1d1d?text=R';">
                        <div class="flex flex-col items-center text-center"> 
                            <span class="text-xl font-bold">${currentRankName}</span>
                            <span class="text-2xl text-red-400 font-bold">${currentRR} RR</span>
                            ${lastMatchRRChangeString}
                        </div>
                    </div>
                `;
            } else if (playerRankSection) { // mmrDataがないか、ランク情報がない場合
                 playerRankSection.innerHTML = `
                    <div class="flex flex-col items-center justify-center mt-1">
                        <img src="https://placehold.co/80x80/1f2937/7f1d1d?text=R" alt="Unranked" class="w-20 h-20 object-contain mb-2">
                        <div class="flex flex-col items-center text-center">
                            <span class="text-xl font-bold">ランク情報なし</span>
                            <span class="text-lg text-gray-400">-- RR</span>
                        </div>
                    </div>
                `;
            }
            
            // Calculate and render Tracker Score (これは processedMatchHistory を使う)
            renderPlayerOverallStats(processedMatchHistory);

            // Render Match History (これも processedMatchHistory を使う)
            const matchHistoryBody = document.getElementById('matchHistoryBody');
            const matchHistoryMobile = document.getElementById('matchHistoryMobile');
            matchHistoryBody.innerHTML = ''; 
            matchHistoryMobile.innerHTML = '';
            
            processedMatchHistory.forEach(match => {
                let matchRankPoints = "-- RR"; // デフォルト
                const historyEntry = mmrHistory.find(h => h.match_id === match.matchId); 

                if (historyEntry) {
                    const rrChange = historyEntry.mmr_change_to_last_game;
                    const currentRRInTier = historyEntry.ranking_in_tier; // 名前を明確化
                    const sign = rrChange >= 0 ? '+' : '';
                    matchRankPoints = `${sign}${rrChange} RR (${currentRRInTier} RR)`;
                    
                    // MMR履歴からランク名とアイコンを更新 (もしあれば)
                    if (historyEntry.currenttier_patched) {
                        match.rankName = historyEntry.currenttier_patched;
                        if (rankNameMapping[match.rankName]) {
                            const japaneseFileName = rankNameMapping[match.rankName];
                            match.rankIcon = `../assets/images/ranks/${japaneseFileName}.png`;
                        } else {
                             match.rankIcon = 'https://placehold.co/48x48/1f2937/7f1d1d?text=R';
                        }
                    }
                }

                // デスクトップ用テーブル行
                const row = `
                    <tr class="hover:bg-gray-700/50 transition-colors">
                        <td class="p-4 font-semibold">${match.map}</td>
                        <td class="p-4">
                            <div class="flex items-center gap-3">
                                <img src="${match.agentIcon}" alt="${match.agentName}" class="w-8 h-8 rounded-full object-contain" onerror="this.onerror=null; this.src='https://placehold.co/32x32/1f2937/7f1d1d?text=?';">
                                <span>${match.agentName}</span>
                            </div>
                        </td>
                        <td class="p-2"> 
                            <div class="flex items-center"> 
                                <img src="${match.rankIcon}" alt="${match.rankName}" class="w-16 h-16 object-contain" onerror="this.onerror=null; this.src='https://placehold.co/64x64/1f2937/7f1d1d?text=R';">
                                <div class="flex flex-col ml-1 text-xs"> 
                                    <span>${match.rankName}</span> 
                                    <span class="text-gray-400">${matchRankPoints}</span>
                                </div>
                            </div>
                        </td>
                        <td class="p-4 font-bold ${match.resultColor}">${match.result} (${match.score})</td>
                        <td class="p-4">${match.kda}</td>
                        <td class="p-4">${match.kd}</td>
                        <td class="p-4">${match.hs}%</td>
                        <td class="p-4 font-bold text-red-400">${match.acs}</td>
                    </tr>
                `;
                matchHistoryBody.innerHTML += row;

                // モバイル用カード
                const card = `
                    <div class="match-card p-4 rounded-xl shadow-lg">
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center gap-3">
                                <img src="${match.agentIcon}" alt="${match.agentName}" class="w-10 h-10 rounded-full object-contain" onerror="this.onerror=null; this.src='https://placehold.co/32x32/1f2937/7f1d1d?text=?';">
                                <div>
                                    <div class="font-bold text-sm">${match.agentName}</div>
                                    <div class="text-gray-400 text-xs">${match.map}</div>
                                </div>
                            </div>
                            <div class="text-right">
                                <div class="font-bold ${match.resultColor} text-sm">${match.result}</div>
                                <div class="text-gray-400 text-xs">${match.score}</div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-3 mb-3">
                            <div class="bg-gray-700/50 rounded-lg p-2 text-center">
                                <div class="text-xs text-gray-400 mb-1">KDA</div>
                                <div class="font-semibold text-sm">${match.kda}</div>
                            </div>
                            <div class="bg-gray-700/50 rounded-lg p-2 text-center">
                                <div class="text-xs text-gray-400 mb-1">K/D</div>
                                <div class="font-semibold text-sm">${match.kd}</div>
                            </div>
                            <div class="bg-gray-700/50 rounded-lg p-2 text-center">
                                <div class="text-xs text-gray-400 mb-1">HS%</div>
                                <div class="font-semibold text-sm">${match.hs}%</div>
                            </div>
                            <div class="bg-gray-700/50 rounded-lg p-2 text-center">
                                <div class="text-xs text-gray-400 mb-1">ACS</div>
                                <div class="font-semibold text-sm text-red-400">${match.acs}</div>
                            </div>
                        </div>
                        
                        <div class="flex items-center justify-between pt-2 border-t border-gray-700/50">
                            <div class="flex items-center gap-2">
                                <img src="${match.rankIcon}" alt="${match.rankName}" class="w-8 h-8 object-contain" onerror="this.onerror=null; this.src='https://placehold.co/32x32/1f2937/7f1d1d?text=R';">
                                <div class="text-xs">
                                    <div class="font-medium">${match.rankName}</div>
                                    <div class="text-gray-400">${matchRankPoints}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                matchHistoryMobile.innerHTML += card;
            });

            // Render ACS Chart (これも processedMatchHistory を使う)
            updateStatsChart();
        }

        function renderPlayerOverallStats(playerData) {
            const trackerScoreEl = document.getElementById('trackerScore');
            const trackerTierEl = document.getElementById('trackerTier');
            const statAvgAcsEl = document.getElementById('statAvgAcs');
            const statAvgKdEl = document.getElementById('statAvgKd');
            const statWinRateEl = document.getElementById('statWinRate');
            const statAvgDdDeltaEl = document.getElementById('statAvgDdDelta');

            // --- ティアとそれに対応するスタイルクラスの定義 (関数の早い段階で定義) ---
            const tierStylesDefinition = {
                s: { bgClass: 'tier-s', labelTextClass: 'text-blue-100', valueTextClass: 'text-white' },
                a: { bgClass: 'tier-a', labelTextClass: 'text-green-100', valueTextClass: 'text-white' },
                b: { bgClass: 'tier-b', labelTextClass: 'text-yellow-700', valueTextClass: 'text-gray-800' },
                c: { bgClass: 'tier-c', labelTextClass: 'text-gray-200', valueTextClass: 'text-white' },
                d: { bgClass: 'tier-d', labelTextClass: 'text-red-100', valueTextClass: 'text-white' },
                default: { bgClass: 'bg-gray-700', labelTextClass: 'text-gray-300', valueTextClass: 'text-white' }
            };

            // スタイルクラスのリスト (これも早期に定義)
            const allBgStyleClasses = Object.values(tierStylesDefinition).map(s => s.bgClass).filter(Boolean);
            const allLabelTextStyleClasses = Object.values(tierStylesDefinition).map(s => s.labelTextClass).filter(Boolean);
            const allValueTextStyleClasses = Object.values(tierStylesDefinition).map(s => s.valueTextClass).filter(Boolean);

            // playerData が空の場合の早期リターンとスタイル設定
            if (playerData.length === 0) {
                trackerScoreEl.textContent = "---";
                trackerTierEl.textContent = "--";
                trackerTierEl.className = 'mt-3 text-2xl font-bold px-8 py-2 rounded-full shadow-md bg-gray-700'; // Default tier display

                const defaultStyle = tierStylesDefinition.default;
                const elementsToReset = {
                    avgAcs: { card: document.getElementById('statCardAvgAcs'), valueEl: statAvgAcsEl, tierEl: document.getElementById('statTierAvgAcs') },
                    avgKd: { card: document.getElementById('statCardAvgKd'), valueEl: statAvgKdEl, tierEl: document.getElementById('statTierAvgKd') },
                    winRate: { card: document.getElementById('statCardWinRate'), valueEl: statWinRateEl, tierEl: document.getElementById('statTierWinRate') },
                    avgDdDelta: { card: document.getElementById('statCardAvgDdDelta'), valueEl: statAvgDdDeltaEl, tierEl: document.getElementById('statTierAvgDdDelta') }
                };

                for (const key in elementsToReset) {
                    const el = elementsToReset[key];
                    if (!el.card || !el.valueEl || !el.tierEl) continue;

                    el.card.classList.remove(...allBgStyleClasses);
                    el.card.classList.add(defaultStyle.bgClass);

                    const labelSpan = el.card.children[0];
                    if (labelSpan) {
                        labelSpan.classList.remove(...allLabelTextStyleClasses);
                        labelSpan.classList.add(defaultStyle.labelTextClass);
                    }
                    el.valueEl.textContent = "N/A";
                    el.valueEl.classList.remove(...allValueTextStyleClasses);
                    el.valueEl.classList.add(defaultStyle.valueTextClass);
                    
                    el.tierEl.textContent = "--";
                    el.tierEl.classList.remove(...allValueTextStyleClasses);
                    el.tierEl.classList.add(defaultStyle.valueTextClass);
                }
                return; // 早期リターン
            }

            // --- メインの統計計算と表示ロジック (playerData が空でない場合) ---
            const avgAcs = playerData.reduce((sum, d) => sum + d.acs, 0) / playerData.length;
            const totalKills = playerData.reduce((sum, d) => sum + d.kills, 0);
            const totalDeaths = playerData.reduce((sum, d) => sum + d.deaths, 0);
            const avgKd = totalDeaths === 0 ? totalKills : totalKills / totalDeaths;
            const avgHs = playerData.reduce((sum, d) => sum + parseFloat(d.hs), 0) / playerData.length;

            const wins = playerData.filter(d => d.resultBoolean).length;
            const totalGames = playerData.length;
            const winRate = totalGames > 0 ? (wins / totalGames) * 100 : 0;

            let totalRoundAvgDdDelta = 0;
            let validDdDeltaGamesCount = 0;
            playerData.forEach(d => {
                if (d.roundsPlayed > 0 && typeof d.damageDealt === 'number' && typeof d.damageReceived === 'number') {
                    const roundDdDelta = (d.damageDealt - d.damageReceived) / d.roundsPlayed;
                    if (!isNaN(roundDdDelta) && isFinite(roundDdDelta)) {
                        totalRoundAvgDdDelta += roundDdDelta;
                        validDdDeltaGamesCount++;
                    }
                }
            });
            const calculatedAvgDdDelta = validDdDeltaGamesCount > 0 ? Math.round(totalRoundAvgDdDelta / validDdDeltaGamesCount) : null;

            // Tracker Score 計算 (これは全体のトラッカースコア用)
            const rawScore = (avgAcs * 0.9) + (avgKd * 40) + (avgHs * 1.2);
            const scalingFactor = 2.25;
            let finalScore = Math.round(rawScore * scalingFactor);
            finalScore = Math.min(finalScore, 999);
            finalScore = Math.max(finalScore, 0);
            trackerScoreEl.textContent = finalScore;

            let overallTier = '';
            let overallTierClass = ''; // Tracker Score 全体のティア表示用クラス名
            if (finalScore >= 800) { overallTier = 'S'; overallTierClass = 'tier-s'; }
            else if (finalScore >= 600) { overallTier = 'A'; overallTierClass = 'tier-a'; }
            else if (finalScore >= 400) { overallTier = 'B'; overallTierClass = 'tier-b'; }
            else if (finalScore >= 200) { overallTier = 'C'; overallTierClass = 'tier-c'; }
            else { overallTier = 'D'; overallTierClass = 'tier-d'; }
            trackerTierEl.textContent = overallTier;
            trackerTierEl.className = 'mt-3 text-2xl font-bold px-8 py-2 rounded-full shadow-md ' + overallTierClass;

            // 各統計項目の要素と値のマッピング
            const statElements = {
                avgAcs:   { card: document.getElementById('statCardAvgAcs'),   valueEl: statAvgAcsEl,   tierEl: document.getElementById('statTierAvgAcs'),   type: 'acs',     val: Math.round(avgAcs) },
                avgKd:    { card: document.getElementById('statCardAvgKd'),    valueEl: statAvgKdEl,    tierEl: document.getElementById('statTierAvgKd'),    type: 'kd',      val: parseFloat(avgKd.toFixed(2)) },
                winRate:  { card: document.getElementById('statCardWinRate'),  valueEl: statWinRateEl,  tierEl: document.getElementById('statTierWinRate'),  type: 'winRate', val: parseFloat(winRate.toFixed(1)) },
                avgDdDelta: { card: document.getElementById('statCardAvgDdDelta'), valueEl: statAvgDdDeltaEl, tierEl: document.getElementById('statTierAvgDdDelta'), type: 'ddDelta', val: calculatedAvgDdDelta }
            };

            // スタイル適用ループ
            for (const key in statElements) {
                const el = statElements[key];
                if (!el.card || !el.valueEl || !el.tierEl) continue; 

                const itemTierKey = (el.val === null || typeof el.val === 'undefined') ? 'default' : getTier(el.val, el.type);
                const currentItemStyle = tierStylesDefinition[itemTierKey] || tierStylesDefinition.default;
                
                const labelSpan = el.card.children[0]; 

                el.card.classList.remove(...allBgStyleClasses);
                el.card.classList.add(currentItemStyle.bgClass);

                if (labelSpan) {
                    labelSpan.classList.remove(...allLabelTextStyleClasses);
                    labelSpan.classList.add(currentItemStyle.labelTextClass);
                }
                
                el.valueEl.classList.remove(...allValueTextStyleClasses);
                el.valueEl.classList.add(currentItemStyle.valueTextClass);
                
                const tierLetter = (itemTierKey === 'default') ? '--' : itemTierKey.toUpperCase();
                el.tierEl.textContent = tierLetter;
                el.tierEl.classList.remove(...allValueTextStyleClasses);
                el.tierEl.classList.add(currentItemStyle.valueTextClass);
            }

            // 値の表示更新 (statElementsループ内でも良いが、ここでまとめて行う)
            statAvgAcsEl.textContent = Math.round(avgAcs);
            statAvgKdEl.textContent = avgKd.toFixed(2);
            statWinRateEl.textContent = `${winRate.toFixed(1)}% (${wins}/${totalGames})`;
            statAvgDdDeltaEl.textContent = (calculatedAvgDdDelta === null) ? "N/A" : calculatedAvgDdDelta;
        }

        function getTier(value, type) {
            switch (type) {
                case 'acs':
                    if (value >= 220) return 's';
                    if (value >= 180) return 'a';
                    if (value >= 140) return 'b';
                    if (value >= 100) return 'c';
                    return 'd';
                case 'kd':
                    if (value >= 1.3) return 's';
                    if (value >= 1.1) return 'a';
                    if (value >= 0.9) return 'b';
                    if (value >= 0.7) return 'c';
                    return 'd';
                case 'winRate':
                    if (value >= 65) return 's';
                    if (value >= 55) return 'a';
                    if (value >= 45) return 'b';
                    if (value >= 35) return 'c';
                    return 'd';
                case 'ddDelta':
                    if (value >= 20) return 's';
                    if (value >= 10) return 'a';
                    if (value >= 0) return 'b';
                    if (value >= -10) return 'c';
                    return 'd';
                default:
                    console.warn(`Unknown tier type encountered: ${type}`);
                    return 'default'; // Ensure a string is always returned
            }
        }

        function updateStatsChart() {
            if (!lastProcessedMatchHistory || lastProcessedMatchHistory.length === 0) {
                // データがない場合はグラフをクリアまたは非表示にする (任意)
                if (statsChartInstance) {
                    statsChartInstance.destroy();
                    statsChartInstance = null;
                }
                document.getElementById('chartTitle').textContent = 'グラフデータがありません';
                return;
            }

            let chartData = [];
            let yAxisLabel = '';
            let chartTitleText = '';
            let datasetLabel = '';

            switch (currentChartType) {
                case 'acs':
                    chartData = lastProcessedMatchHistory.map(match => match.acs);
                    yAxisLabel = 'ACS';
                    datasetLabel = 'ACS';
                    chartTitleText = 'ACS (Average Combat Score) 推移';
                    break;
                case 'kd':
                    chartData = lastProcessedMatchHistory.map(match => parseFloat(match.kd) || 0);
                    yAxisLabel = 'K/D Ratio';
                    datasetLabel = 'K/D';
                    chartTitleText = 'K/D 比率 推移';
                    break;
                case 'ddDelta':
                    chartData = lastProcessedMatchHistory.map(match => {
                        if (match.roundsPlayed > 0 && typeof match.damageDealt === 'number' && typeof match.damageReceived === 'number') {
                            return Math.round((match.damageDealt - match.damageReceived) / match.roundsPlayed);
                        }
                        return 0; // データ不備またはラウンド数0の場合は0
                    });
                    yAxisLabel = 'DDΔ / Round';
                    datasetLabel = 'DDΔ';
                    chartTitleText = 'ラウンド毎ダメージ差 (DDΔ) 推移';
                    break;
                case 'hs':
                    chartData = lastProcessedMatchHistory.map(match => parseFloat(match.hs) || 0);
                    yAxisLabel = 'HS %';
                    datasetLabel = 'HS%';
                    chartTitleText = 'ヘッドショット率 (%) 推移';
                    break;
                default:
                    console.error('Unknown chart type:', currentChartType);
                    return;
            }

            document.getElementById('chartTitle').textContent = chartTitleText;

            const ctx = document.getElementById('statsChart').getContext('2d');
            
            if (statsChartInstance) {
                statsChartInstance.destroy();
            }

            const labels = lastProcessedMatchHistory.length > 0 ? lastProcessedMatchHistory.map((_, i) => `Match ${lastProcessedMatchHistory.length - i}`).reverse() : [];

            statsChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: datasetLabel,
                        data: chartData,
                        borderColor: 'rgb(239, 68, 68)',       // Tailwind red-500
                        backgroundColor: 'rgba(239, 68, 68, 0.2)', // Tailwind red-500 with alpha
                        tension: 0.3,
                        fill: true,
                        pointBackgroundColor: '#fff',
                        pointBorderColor: 'rgb(239, 68, 68)',
                        pointHoverRadius: 7,
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: false, // HS%やDDΔは0始まりでない方が見やすい場合がある
                            title: { display: true, text: yAxisLabel, color: '#9ca3af' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#9ca3af' }
                        },
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#9ca3af' }
                        }
                    },
                    plugins: {
                        legend: { display: true, labels: { color: '#9ca3af' } } // 凡例は表示し、文字色を設定
                    }
                }
            });
        }

        // --- UTILITY FUNCTIONS ---
        function setLoadingState(isLoading) {
            if (isLoading) {
                searchButton.disabled = true;
                searchIcon.classList.add('hidden');
                loadingIcon.classList.remove('hidden');
                buttonText.textContent = '検索中...';
            } else {
                searchButton.disabled = false;
                searchIcon.classList.remove('hidden');
                loadingIcon.classList.add('hidden');
                buttonText.textContent = '検索';
            }
        }

        function showError(message) {
            // 改行文字を<br>タグに変換して表示
            const formattedMessage = message.replace(/\n/g, '<br>');
            errorMessage.innerHTML = formattedMessage;
            errorModal.classList.remove('hidden');
            
            // デバッグ用：エラーメッセージもコンソールに出力
            console.error('[エラー表示]', message);
        }
    </script>
</body>
</html>

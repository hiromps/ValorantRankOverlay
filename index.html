<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VALORANT Tracker Overlay</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Rajdhani:wght@400;500;600;700&family=Orbitron:wght@400;500;700;800;900&display=swap" rel="stylesheet">
    <!-- Google AdSense script -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6090439809602995"
     crossorigin="anonymous"></script>
 <style>
        /* 基本的なヘッダースタイル */
        .app-header {
            padding: 1rem;
            background-color: rgba(15, 25, 35, 0.95);
            border-bottom: 2px solid #ff4655;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
            width: 100%;
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .nav-buttons {
            display: flex;
            gap: 1rem;
        }
        .app-header button,
        .app-header a.header-button {
            background-color: #ff4655;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            margin: 0 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            text-decoration: none; /* 下線を消す */
            display: inline-block; /* ボタンらしく見せるため */
            box-shadow: 0 2px 8px rgba(255, 70, 85, 0.3);
        }
        .app-header button:hover,
        .app-header a.header-button:hover {
            background-color: #e0303f;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 70, 85, 0.4);
        }
        .app-header button.active,
        .app-header a.header-button.active {
            background-color: #22c55e; /* 緑などでアクティブ状態を示す */
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.5);
            text-decoration: none; /* アクティブ時も下線を消す */
        }
        @media screen and (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 1rem;
                padding: 0 10px;
                align-items: center;
            }
            .nav-buttons {
                flex-direction: row;
                width: 100%;
                gap: 0.3rem;
                justify-content: center;
                flex-wrap: nowrap;
                overflow-x: auto;
            }
            .nav-buttons .header-button {
                width: auto;
                text-align: center;
                margin: 0;
                padding: 0.4rem 0.7rem;
                font-size: 0.85rem;
                min-width: 80px;
                white-space: nowrap;
            }
            .author-section {
                margin-top: 10px;
            }
        }
        .mode-container {
            /* display: none; */ /* 初期状態はJSで制御 */
        }
        .hidden {
            display: none !important;
        }
        #showOverlayModeLink {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #showTrackerModeLink {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .theme-selector {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .theme-button {
            padding: 0.5rem 1rem;
            border: 2px solid #374151;
            background: transparent;
            color: #9ca3af;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.875rem;
            font-weight: 500;
        }
        .theme-button:hover {
            border-color: #6b7280;
            color: #d1d5db;
        }
        .theme-button.active {
            border-color: #ff4655;
            background: #ff4655;
            color: white;
        }
        /* 全テーマ共通 - 文字途切れ防止 */
        .overlay .rank-name {
            white-space: nowrap;
            overflow: visible;
            text-overflow: unset;
            min-width: 0;
            word-break: keep-all;
        }

        .overlay .rr {
            white-space: nowrap;
            overflow: visible;
            text-overflow: unset;
        }

        .overlay .last-match-text {
            white-space: nowrap;
            overflow: visible;
            text-overflow: unset;
        }

        .overlay .rank-details {
            min-width: 0;
            flex: 1;
            overflow: visible;
        }

        .overlay .rank-name-line {
            min-width: 0;
            overflow: visible;
            flex-wrap: wrap;
            gap: 5px;
        }
        /* テーマ別スタイル */
        /* クラシックテーマ（現在のデザイン） */
        .theme-classic .overlay {
            background: var(--overlay-bg-color);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: none;
            width: auto;
            min-width: 300px;
            max-width: 400px;
        }

        .theme-classic .rank-section {
            background: var(--rank-bg-color);
            padding: 6px 10px;
        }

        .theme-classic .rank-icon {
            width: 60px;
            height: 60px;
            border: none !important;
            box-shadow: none !important;
            background: none !important;
            outline: none !important;
        }

        .theme-classic .rank-name {
            font-size: clamp(1rem, 3.5vw, 1.3rem);
        }

        .theme-classic .rr {
            font-size: clamp(0.95rem, 3vw, 1.2rem);
            margin-right: 8px;
        }

        .theme-classic .last-match-section {
            background-color: var(--last-match-bg-color);
            padding: 6px 10px;
        }

        .theme-classic .last-match-text {
            color: var(--text-color);
            font-weight: 600;
            font-size: clamp(0.9rem, 2.5vw, 1rem) !important;
            line-height: 1.3;
        }

        /* モダンテーマ - カード分割レイアウト */
        .theme-modern .overlay {
            background: transparent;
            backdrop-filter: none;
            border: none;
            border-radius: 0;
            box-shadow: none;
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            width: auto;
            min-width: 320px;
            max-width: 380px;
        }

        .theme-modern .rank-section {
            background: var(--rank-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 14px 18px;
            box-shadow: none;
            position: relative;
            overflow: hidden;
            min-height: auto;
        }

        .theme-modern .rank-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #ec4899);
            border-radius: 16px 16px 0 0;
        }

        .theme-modern .rank-icon {
            width: 52px;
            height: 52px;
            border-radius: 12px;
            flex-shrink: 0;
            border: none !important;
            box-shadow: none !important;
            background: none !important;
            outline: none !important;
        }

        .theme-modern .rank-name {
            font-size: clamp(1rem, 3vw, 1.15rem);
            font-weight: 700;
            background: linear-gradient(135deg, #f1f5f9, #cbd5e1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.2;
        }

        .theme-modern .rr {
            font-size: clamp(1.1rem, 3.5vw, 1.3rem);
            font-weight: 800;
            color: var(--rr-color);
            text-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            line-height: 1.1;
        }

        .theme-modern .last-match-section {
            background: var(--last-match-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 12px 18px;
            box-shadow: none;
            position: relative;
            min-height: auto;
            width: 100%;
            overflow: hidden;
        }

        .theme-modern .last-match-text {
            color: var(--text-color);
            font-weight: 600;
            font-size: clamp(0.9rem, 2.5vw, 1rem) !important;
            line-height: 1.3;
            width: 100%;
            text-align: center;
            position: relative;
            z-index: 1;
        }

        /* Cyberテーマ - VALORANT風サイバーテック */
        .theme-shadcn .overlay {
            background: transparent;
            backdrop-filter: none;
            border: none;
            border-radius: 0;
            box-shadow: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: auto;
            min-width: 340px;
            max-width: 420px;
            padding: 0;
            position: relative;
        }

        .theme-shadcn .rank-section {
            background: var(--rank-bg-color);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--border-color);
            border-radius: 12px;
            padding: 14px 18px;
            position: relative;
            overflow: hidden;
            box-shadow: none;
            min-height: auto;
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .theme-shadcn .rank-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, 
                var(--border-color) 0%, 
                #00f5ff 50%, 
                var(--border-color) 100%
            );
        }

        .theme-shadcn .rank-section::after {
            content: '';
            position: absolute;
            top: 6px;
            right: 6px;
            width: 6px;
            height: 6px;
            background: #00f5ff;
            border-radius: 50%;
            box-shadow: 0 0 6px #00f5ff;
            animation: pulse-valorant 2s ease-in-out infinite;
        }

        .theme-shadcn .rank-icon {
            width: 52px;
            height: 52px;
            border-radius: 8px;
            flex-shrink: 0;
            border: none !important;
            box-shadow: none !important;
            background: none !important;
            outline: none !important;
        }

        .theme-shadcn .rank-details {
            display: flex;
            flex-direction: column;
            gap: 3px;
            align-items: flex-start;
            flex: 1;
        }

        .theme-shadcn .rank-name-line {
            display: flex;
            flex-direction: column;
            gap: 1px;
            align-items: flex-start;
            width: 100%;
        }

        .theme-shadcn .rank-name {
            color: var(--text-color);
            font-weight: 700;
            font-size: clamp(1.1rem, 3.5vw, 1.3rem);
            line-height: 1.1;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-family: 'Rajdhani', 'Arial', sans-serif;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        }

        .theme-shadcn .rr {
            color: var(--rr-color);
            font-weight: 800;
            font-size: clamp(1.3rem, 4.5vw, 1.6rem);
            line-height: 1;
            font-family: 'Orbitron', 'Arial', sans-serif;
            letter-spacing: 2px;
            text-shadow: 
                0 0 10px rgba(255, 70, 85, 0.6),
                0 0 20px rgba(255, 70, 85, 0.3);
        }

        .theme-shadcn .last-match-section {
            background: var(--last-match-bg-color);
            border: 1px solid var(--border-color);
            border-right: 4px solid var(--border-color);
            border-radius: 12px;
            padding: 12px 18px;
            position: relative;
            overflow: hidden;
            box-shadow: none;
            min-height: auto;
            width: 100%;
        }

        .theme-shadcn .last-match-section::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, 
                #00f5ff 0%, 
                var(--border-color) 50%, 
                #00f5ff 100%
            );
        }

        .theme-shadcn .last-match-section::after {
            content: '';
            position: absolute;
            bottom: 6px;
            left: 6px;
            width: 5px;
            height: 5px;
            background: var(--border-color);
            border-radius: 50%;
            box-shadow: 0 0 5px var(--border-color);
            animation: pulse-valorant 2.5s ease-in-out infinite;
        }

        .theme-shadcn .last-match-text {
            color: var(--text-color);
            font-weight: 600;
            font-size: clamp(1rem, 3.2vw, 1.2rem) !important;
            line-height: 1.2;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Rajdhani', 'Arial', sans-serif;
            text-shadow: 0 0 6px rgba(255, 255, 255, 0.2);
            width: 100%;
            position: relative;
            z-index: 1;
        }

        .theme-shadcn .mmr-gauge-fill {
            background: linear-gradient(90deg, 
                var(--rr-color) 0%, 
                #00f5ff 50%, 
                var(--rr-color) 100%
            );
            border-radius: 0;
            box-shadow: 
                0 0 8px rgba(255, 70, 85, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            height: 3px;
        }

        /* テクノロジー風スキャンライン効果 */
        @keyframes scan-line {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(400px); }
        }

        .theme-shadcn .rank-section .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(to bottom, 
                transparent 0%, 
                #00f5ff 50%, 
                transparent 100%
            );
            animation: scan-line 3s linear infinite;
            pointer-events: none;
        }

        /* Neonテーマ - サイバーパンク風 */
        .theme-neon .overlay {
            background: transparent;
            backdrop-filter: none;
            border: none;
            border-radius: 0;
            box-shadow: none;
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: auto;
            min-width: 340px;
            max-width: 420px;
        }

        .theme-neon .rank-section {
            background: var(--rank-bg-color);
            border: 2px solid transparent;
            background-clip: padding-box;
            border-radius: 20px;
            padding: 18px 20px;
            position: relative;
            overflow: hidden;
            box-shadow: none;
            min-height: auto;
        }

        .theme-neon .rank-section::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--border-color), #ff00ff, #ffff00, var(--border-color));
            border-radius: 20px;
            z-index: -1;
            animation: neonBorder 3s linear infinite;
        }

        .theme-neon .rank-section::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--rank-bg-color);
            border-radius: 18px;
            z-index: -1;
        }

        .theme-neon .rank-icon {
            width: 60px;
            height: 60px;
            border-radius: 16px;
            flex-shrink: 0;
            border: none !important;
            box-shadow: none !important;
            background: none !important;
            outline: none !important;
        }

        .theme-neon .rank-name {
            font-size: clamp(1.1rem, 3.5vw, 1.25rem);
            font-weight: 800;
            color: var(--text-color);
            text-shadow: 
                0 0 10px rgba(0, 255, 255, 0.8),
                0 0 20px rgba(0, 255, 255, 0.5),
                0 0 30px rgba(0, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
            line-height: 1.1;
        }

        .theme-neon .rr {
            font-size: clamp(1.25rem, 4.5vw, 1.5rem);
            font-weight: 900;
            color: var(--rr-color);
            text-shadow: 
                0 0 10px rgba(255, 0, 255, 0.8),
                0 0 20px rgba(255, 0, 255, 0.5);
            line-height: 1;
        }

        .theme-neon .last-match-section {
            background: var(--last-match-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 12px 18px;
            position: relative;
            box-shadow: none;
            min-height: auto;
            width: 100%;
            overflow: hidden;
        }

        .theme-neon .last-match-text {
            color: var(--text-color);
            font-weight: 700;
            font-size: clamp(0.95rem, 3vw, 1.05rem) !important;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1.2;
            width: 100%;
            text-align: center;
            position: relative;
            z-index: 1;
        }

        .theme-neon .mmr-gauge-fill {
            background: linear-gradient(90deg, var(--rr-color), #ff00ff);
            border-radius: 0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        @keyframes neonBorder {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse-valorant {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }
    </style>
</head>
<body>
    <header class="app-header">
        <div class="header-content">
            <div class="nav-buttons">
                <a href="/" id="showOverlayModeLink" class="header-button active">OBSオーバーレイ</a>
                <a href="./valorant-stats-tracker/" id="showTrackerModeLink" class="header-button">戦績トラッカー</a>
            </div>
            <div class="author-section">
                <p class="author-text">Project by にど寝</p>
                <img src="assets/images/nidone.png" alt="製作者アバター" class="author-avatar">
            </div>
        </div>
    </header>
    <div class="background"></div>

    <!-- Google AdSense広告ユニット -->
    <div class="ad-container">
        <ins class="adsbygoogle"
             style="display:block"
             data-ad-client="ca-pub-6090439809602995"
             data-ad-slot="1000000000000000"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
        <script>
             (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
    </div>

    <!-- メインコンテンツコンテナ -->
    <div class="main-content-container">
        <div id="inputSection" class="input-section">
            <h2>VALORANT プレイヤー情報</h2>
            <div class="input-form">
                <input type="text" id="playerName" placeholder="プレイヤー名" required>
                <input type="text" id="playerTag" placeholder="タグ" required>
                <button onclick="generateURL()">URLを生成</button>
            </div>
            <div class="url-output">
                <input type="text" id="generatedURL" readonly>
                <button onclick="copyURL()">コピー</button>
            </div>
        </div>

        <div class="right-column">
            <div class="overlay">
                <div class="rank-section">
                    <img src="assets/images/ranks/ランクなし.png" alt="Rank Icon" class="rank-icon" id="rankIcon">
                    <div class="rank-details">
                        <div class="rank-name-line">
                            <span class="rank-name" id="rankText">ランクなし</span> <span class="rr" id="rrText">0RR</span>
                        </div>
                        <!-- <span class="win-loss" id="winLossText">0 Win / 0 Loss</span> -->
                    </div>
                </div>
                <div class="last-match-section" id="lastMatchSection">
                    <div class="mmr-gauge-fill"></div>
                    <span class="last-match-text" id="lastMatchText">前回のマッチ +0pts</span>
                </div>
                <!-- OBS用デバッグ情報 -->
                <div id="obsDebugInfo" style="display: none; font-size: 12px; color: #888; margin-top: 10px;">
                    <div>自動更新: <span id="autoUpdateStatus">無効</span></div>
                    <div>最終更新: <span id="lastUpdateTime">-</span></div>
                    <button onclick="manualUpdate()" style="margin-top: 5px; padding: 2px 8px; font-size: 10px;">手動更新</button>
                </div>
            </div>
            
            <!-- カスタマイズボタン -->
            <div class="customize-button-container">
                <button id="customizeButton">カスタマイズ</button>
            </div>
        </div>
    </div>

    <!-- OBSチュートリアルセクション -->
    <div class="tutorial-section">
        <button class="tutorial-toggle" onclick="toggleTutorial()">
            📺 OBS設定ガイド <span id="tutorialArrow" class="rotated">▼</span>
        </button>
        <div class="tutorial-content expanded" id="tutorialContent">
            <div class="tutorial-step">
                <h4>🎯 ステップ 1: URLを生成</h4>
                <p>上記のフォームにプレイヤー名とタグを入力し、「URLを生成」ボタンを押してください。</p>
            </div>
            <div class="tutorial-step">
                <h4>🖥️ ステップ 2: OBSでブラウザソースを追加</h4>
                <ol>
                    <li>OBS Studioを開く</li>
                    <li>「ソース」の「+」ボタンをクリック</li>
                    <li>「ブラウザ」を選択</li>
                    <li>「新規作成」を選択してOKを押す</li>
                </ol>
            </div>
            <div class="tutorial-step">
                <h4>⚙️ ステップ 3: ブラウザソースの設定（高画質推奨）</h4>
                <ul>
                    <li><strong>URL:</strong> 生成されたURLをコピー&ペースト</li>
                    <li><strong>幅:</strong> 900（高画質）または 450（標準）</li>
                    <li><strong>高さ:</strong> 400（高画質）または 200（標準）</li>
                    <li><strong>カスタムCSS:</strong> そのまま</li>
                </ul>
                <p><strong>💡 ヒント:</strong> 高画質設定後、OBSプレビューで右クリック→「変換」→「画面に合わせる」で適切なサイズに調整できます</p>
            </div>
            <div class="tutorial-step">
                <h4>✨ ステップ 4: 位置とサイズの調整</h4>
                <p>OBSのプレビュー画面でオーバーレイを好きな位置にドラッグして配置してください。</p>
            </div>
            <div class="tutorial-note">
                <h4>📝 注意事項</h4>
                <ul>
                    <li>オーバーレイは30秒間隔で自動更新されます</li>
                    <li>ランク情報が正常に表示されない場合はURLを生成し直してください</li>
                    <li>APIの制限により、一時的にデータが取得できない場合があります</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- カラーピッカーモーダル -->
    <div id="colorPickerModal" class="color-picker-modal">
        <div class="color-picker-content">
            <h3>カスタマイズ</h3>
            <div class="color-picker-section">
                <label>デザインテーマ:</label>
                <div class="theme-selector">
                    <button type="button" id="themeClassic" class="theme-button active" data-theme="classic">クラシック</button>
                    <button type="button" id="themeModern" class="theme-button" data-theme="modern">モダン</button>
                                            <button type="button" id="themeShadcn" class="theme-button" data-theme="shadcn">Cyber</button>
                    <button type="button" id="themeNeon" class="theme-button" data-theme="neon">Neon</button>
                </div>
            </div>
            <div class="color-picker-section">
                <label for="rankBgColorPicker">ランク背景色:</label>
                <input type="color" id="rankBgColorPicker" value="#3a444e">
                <input type="range" id="rankBgOpacitySlider" min="0" max="100" value="100">
                <span id="rankBgOpacityValue">100%</span>
            </div>
            <div class="color-picker-section">
                <label for="lastMatchBgColorPicker">前回のマッチ背景色:</label>
                <input type="color" id="lastMatchBgColorPicker" value="#F44336">
                <input type="range" id="lastMatchBgOpacitySlider" min="0" max="100" value="100">
                <span id="lastMatchBgOpacityValue">100%</span>
            </div>
            <div class="color-picker-section">
                <label for="textColorPicker">文字色:</label>
                <input type="color" id="textColorPicker" value="#ffffff">
            </div>
            <div class="color-picker-section">
                <label for="rrColorPicker">RRテキスト色:</label>
                <input type="color" id="rrColorPicker" value="#ff4655">
            </div>
            <div class="color-picker-section">
                <label for="borderColorPicker">境界線色:</label>
                <input type="color" id="borderColorPicker" value="#ff4655">
                <input type="range" id="borderOpacitySlider" min="0" max="100" value="100">
                <span id="borderOpacityValue">100%</span>
            </div>
            <div class="color-picker-buttons">
                <button onclick="applyCustomColors()">適用</button>
                <button onclick="closeColorPicker()">キャンセル</button>
                <button onclick="resetCustomColors()">リセット</button>
            </div>
        </div>
    </div>

    <script src="config.js"></script>
    <script src="js/api.js"></script>
    <script>
        // グローバル変数でプレイヤー情報と更新間隔を管理
        let currentPlayerName = null;
        let currentPlayerTag = null;
        let updateInterval = null;
        let isAutoUpdateEnabled = false;

        // テーマ選択機能
        let currentTheme = 'classic';

        function applyTheme(theme) {
            const body = document.body;
            // 既存のテーマクラスを削除
            body.classList.remove('theme-classic', 'theme-modern', 'theme-shadcn', 'theme-neon');
            // 新しいテーマクラスを追加
            body.classList.add(`theme-${theme}`);
            currentTheme = theme;
            
            // テーマをlocalStorageに保存
            localStorage.setItem('selectedTheme', theme);
            
            // ボタンのアクティブ状態を更新
            document.querySelectorAll('.theme-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-theme="${theme}"]`).classList.add('active');
            
            // オーバーレイの幅をリセット（全テーマでCSSによる最小幅調整が適用される）
            const overlay = document.querySelector('.overlay');
            if (overlay) {
                // インラインスタイルをクリアしてCSSに委譲
                overlay.style.width = '';
                overlay.style.minWidth = '';
                overlay.style.maxWidth = '';
            }
            
            // Cyberテーマの場合、スキャンライン効果を追加
            if (theme === 'shadcn') {
                setTimeout(addScanLineEffect, 100);
            }
            
            // テーマ変更後に前回のマッチセクションの幅を調整（プレビュー画面のみ）
            setTimeout(() => {
                if (theme === 'classic') {
                    resetLastMatchWidthForClassic();
                } else {
                    adjustLastMatchWidth();
                }
            }, 200);
        }

        // VALORANT風スキャンライン効果を追加
        function addScanLineEffect() {
            const rankSection = document.querySelector('.theme-shadcn .rank-section');
            if (rankSection && !rankSection.querySelector('.scan-line')) {
                const scanLine = document.createElement('div');
                scanLine.className = 'scan-line';
                rankSection.appendChild(scanLine);
            }
        }

        // カラーピッカーモーダルの表示/非表示
        function showColorPicker() {
            const modal = document.getElementById('colorPickerModal');
            modal.style.display = 'flex';
        }

        function closeColorPicker() {
            const modal = document.getElementById('colorPickerModal');
            modal.style.display = 'none';
            
            // モーダルを閉じた後に幅調整を実行（プレビュー画面のみ）
            setTimeout(() => {
                if (currentTheme === 'classic') {
                    resetLastMatchWidthForClassic();
                } else {
                    adjustLastMatchWidth();
                }
            }, 300);
        }

        // 自動更新機能（改善版）
        function startAutoUpdate(intervalSeconds = 60) {
            if (isAutoUpdateEnabled || !currentPlayerName || !currentPlayerTag) {
                return;
            }

            isAutoUpdateEnabled = true;
            console.log(`自動更新を開始しました（${intervalSeconds}秒間隔）`);

            // 定期的にプレイヤー情報を更新
            updateInterval = setInterval(() => {
                if (currentPlayerName && currentPlayerTag) {
                    console.log('プレイヤー情報を自動更新中...');
                    updatePlayerInfo(currentPlayerName, currentPlayerTag).catch(error => {
                        console.error('自動更新中にエラーが発生しました:', error);
                        // エラーが発生しても自動更新は継続
                    });
                }
            }, intervalSeconds * 1000);
        }

        function stopAutoUpdate() {
            if (!isAutoUpdateEnabled) {
                return;
            }

            isAutoUpdateEnabled = false;
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
                console.log('自動更新を停止しました');
            }
        }

        // OBS専用の自動更新機能（より堅牢）
        function startOBSAutoUpdate(intervalSeconds = 60) {
            // 既に開始されている場合は停止してから再開始
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            
            isAutoUpdateEnabled = true;
            console.log(`OBS専用自動更新を開始しました（${intervalSeconds}秒間隔）`);
            
            // ステータス更新
            updateAutoUpdateStatus();

            // 即座に一回実行してから定期実行を開始
            if (currentPlayerName && currentPlayerTag) {
                updatePlayerInfo(currentPlayerName, currentPlayerTag).catch(error => {
                    console.error('初回更新中にエラーが発生しました:', error);
                });
            }

            // 定期実行
            updateInterval = setInterval(() => {
                if (currentPlayerName && currentPlayerTag) {
                    console.log(`[${new Date().toLocaleTimeString()}] プレイヤー情報を自動更新中...`);
                    updatePlayerInfo(currentPlayerName, currentPlayerTag).catch(error => {
                        console.error('自動更新中にエラーが発生しました:', error);
                        // エラーが発生しても自動更新は継続
                    });
                } else {
                    console.warn('プレイヤー情報が設定されていません。自動更新を停止します。');
                    stopAutoUpdate();
                }
            }, intervalSeconds * 1000);
        }

        // 自動更新ステータスを画面に反映
        function updateAutoUpdateStatus() {
            const statusElement = document.getElementById('autoUpdateStatus');
            const timeElement = document.getElementById('lastUpdateTime');
            
            if (statusElement) {
                statusElement.textContent = isAutoUpdateEnabled ? '有効' : '無効';
                statusElement.style.color = isAutoUpdateEnabled ? '#4CAF50' : '#f44336';
            }
            
            if (timeElement) {
                timeElement.textContent = new Date().toLocaleTimeString();
            }
        }

        // ページ非表示/表示時の自動更新制御（OBS用に調整）
        document.addEventListener('visibilitychange', function() {
            const urlParams = new URLSearchParams(window.location.search);
            const isOBS = urlParams.has('obs');
            
            // OBSモードの場合は可視性に関係なく自動更新を継続
            if (isOBS) {
                console.log(`可視性変更: ${document.hidden ? '非表示' : '表示'} - OBSモードのため自動更新継続`);
                return;
            }
            
            if (!currentPlayerName || !currentPlayerTag) {
                return;
            }

            if (document.hidden) {
                // 通常モードでページが非表示になったら更新を一時停止
                if (isAutoUpdateEnabled) {
                    stopAutoUpdate();
                    console.log('ページが非表示になったため自動更新を一時停止');
                }
            } else {
                // 通常モードでページが表示されたら更新を再開
                if (!isAutoUpdateEnabled) {
                    const updateFreq = parseInt(urlParams.get('updateInterval')) || 60;
                    startAutoUpdate(updateFreq);
                    console.log('ページが表示されたため自動更新を再開');
                }
            }
        });

        // ページ離脱時のクリーンアップ
        window.addEventListener('beforeunload', function() {
            stopAutoUpdate();
        });

        // ランク背景色の透明度スライダーの更新
        document.getElementById('rankBgOpacitySlider').addEventListener('input', function(e) {
            document.getElementById('rankBgOpacityValue').textContent = e.target.value + '%';
        });

        // 前回のマッチ背景色の透明度スライダーの更新
        document.getElementById('lastMatchBgOpacitySlider').addEventListener('input', function(e) {
            document.getElementById('lastMatchBgOpacityValue').textContent = e.target.value + '%';
        });

        // 境界線色の透明度スライダーの更新
        document.getElementById('borderOpacitySlider').addEventListener('input', function(e) {
            document.getElementById('borderOpacityValue').textContent = e.target.value + '%';
        });

        // カスタムカラーの適用
        function applyCustomColors() {
            const rankBgColor = document.getElementById('rankBgColorPicker').value;
            const rankBgOpacity = document.getElementById('rankBgOpacitySlider').value;
            const lastMatchBgColor = document.getElementById('lastMatchBgColorPicker').value;
            const lastMatchBgOpacity = document.getElementById('lastMatchBgOpacitySlider').value;
            const textColor = document.getElementById('textColorPicker').value;
            const rrColor = document.getElementById('rrColorPicker').value;
            const borderColor = document.getElementById('borderColorPicker').value;
            const borderOpacity = document.getElementById('borderOpacitySlider').value;

            // ランク背景色をrgba形式に変換
            const rankR = parseInt(rankBgColor.slice(1, 3), 16);
            const rankG = parseInt(rankBgColor.slice(3, 5), 16);
            const rankB = parseInt(rankBgColor.slice(5, 7), 16);
            const rgbaRankBgColor = `rgba(${rankR}, ${rankG}, ${rankB}, ${rankBgOpacity / 100})`;

            // 前回のマッチ背景色をrgba形式に変換
            const lastMatchR = parseInt(lastMatchBgColor.slice(1, 3), 16);
            const lastMatchG = parseInt(lastMatchBgColor.slice(3, 5), 16);
            const lastMatchB = parseInt(lastMatchBgColor.slice(5, 7), 16);
            const rgbaLastMatchBgColor = `rgba(${lastMatchR}, ${lastMatchG}, ${lastMatchB}, ${lastMatchBgOpacity / 100})`;

            // 境界線色をrgba形式に変換
            const borderR = parseInt(borderColor.slice(1, 3), 16);
            const borderG = parseInt(borderColor.slice(3, 5), 16);
            const borderB = parseInt(borderColor.slice(5, 7), 16);
            const rgbaBorderColor = `rgba(${borderR}, ${borderG}, ${borderB}, ${borderOpacity / 100})`;

            // CSS変数を更新
            document.documentElement.style.setProperty('--rank-bg-color', rgbaRankBgColor);
            document.documentElement.style.setProperty('--last-match-bg-color', rgbaLastMatchBgColor);
            document.documentElement.style.setProperty('--text-color', textColor);
            document.documentElement.style.setProperty('--rr-color', rrColor);
            document.documentElement.style.setProperty('--border-color', rgbaBorderColor);

            // 設定を保存
            localStorage.setItem('customRankBgColor', rankBgColor);
            localStorage.setItem('customRankBgOpacity', rankBgOpacity);
            localStorage.setItem('customLastMatchBgColor', lastMatchBgColor);
            localStorage.setItem('customLastMatchBgOpacity', lastMatchBgOpacity);
            localStorage.setItem('customTextColor', textColor);
            localStorage.setItem('customRrColor', rrColor);
            localStorage.setItem('customBorderColor', borderColor);
            localStorage.setItem('customBorderOpacity', borderOpacity);

            closeColorPicker();
            
            // カスタムカラー適用後に幅調整を実行（プレビュー画面のみ）
            setTimeout(() => {
                if (currentTheme === 'classic') {
                    resetLastMatchWidthForClassic();
                } else {
                    adjustLastMatchWidth();
                }
            }, 300);
        }

        // カスタムカラーをリセット
        function resetCustomColors() {
            // デフォルト値に戻す
            document.getElementById('rankBgColorPicker').value = '#3a444e';
            document.getElementById('rankBgOpacitySlider').value = '100';
            document.getElementById('rankBgOpacityValue').textContent = '100%';
            document.getElementById('lastMatchBgColorPicker').value = '#F44336';
            document.getElementById('lastMatchBgOpacitySlider').value = '100';
            document.getElementById('lastMatchBgOpacityValue').textContent = '100%';
            document.getElementById('textColorPicker').value = '#ffffff';
            document.getElementById('rrColorPicker').value = '#ff4655';
            document.getElementById('borderColorPicker').value = '#ff4655';
            document.getElementById('borderOpacitySlider').value = '100';
            document.getElementById('borderOpacityValue').textContent = '100%';

            // CSS変数をリセット
            document.documentElement.style.setProperty('--rank-bg-color', 'rgba(58, 68, 78, 1)');
            document.documentElement.style.setProperty('--last-match-bg-color', 'rgba(244, 67, 54, 1)');
            document.documentElement.style.setProperty('--text-color', '#ffffff');
            document.documentElement.style.setProperty('--rr-color', '#ff4655');
            document.documentElement.style.setProperty('--border-color', 'rgba(255, 70, 85, 1)');

            // localStorageからカスタム設定を削除
            localStorage.removeItem('customRankBgColor');
            localStorage.removeItem('customRankBgOpacity');
            localStorage.removeItem('customLastMatchBgColor');
            localStorage.removeItem('customLastMatchBgOpacity');
            localStorage.removeItem('customTextColor');
            localStorage.removeItem('customRrColor');
            localStorage.removeItem('customBorderColor');
            localStorage.removeItem('customBorderOpacity');

            // テーマをクラシックに戻す
            applyTheme('classic');
            
            // リセット後に幅調整を実行（プレビュー画面のみ）
            setTimeout(() => {
                // リセット後はクラシックテーマになるので、クラシック用の処理を実行
                resetLastMatchWidthForClassic();
            }, 300);
        }

        // 保存された設定を読み込む
        function loadSavedSettings() {
            const savedRankBgColor = localStorage.getItem('customRankBgColor');
            const savedRankBgOpacity = localStorage.getItem('customRankBgOpacity');
            const savedLastMatchBgColor = localStorage.getItem('customLastMatchBgColor');
            const savedLastMatchBgOpacity = localStorage.getItem('customLastMatchBgOpacity');
            const savedTextColor = localStorage.getItem('customTextColor');
            const savedRrColor = localStorage.getItem('customRrColor');
            const savedBorderColor = localStorage.getItem('customBorderColor');
            const savedBorderOpacity = localStorage.getItem('customBorderOpacity');
            const savedTheme = localStorage.getItem('selectedTheme');

            if (savedRankBgColor && savedRankBgOpacity && savedTextColor) {
                // ランク背景色の設定
                const rankR = parseInt(savedRankBgColor.slice(1, 3), 16);
                const rankG = parseInt(savedRankBgColor.slice(3, 5), 16);
                const rankB = parseInt(savedRankBgColor.slice(5, 7), 16);
                const rgbaRankBgColor = `rgba(${rankR}, ${rankG}, ${rankB}, ${savedRankBgOpacity / 100})`;

                // 前回のマッチ背景色の設定
                if (savedLastMatchBgColor && savedLastMatchBgOpacity) {
                    const lastMatchR = parseInt(savedLastMatchBgColor.slice(1, 3), 16);
                    const lastMatchG = parseInt(savedLastMatchBgColor.slice(3, 5), 16);
                    const lastMatchB = parseInt(savedLastMatchBgColor.slice(5, 7), 16);
                    const rgbaLastMatchBgColor = `rgba(${lastMatchR}, ${lastMatchG}, ${lastMatchB}, ${savedLastMatchBgOpacity / 100})`;
                    document.documentElement.style.setProperty('--last-match-bg-color', rgbaLastMatchBgColor);
                }

                // 境界線色の設定
                if (savedBorderColor && savedBorderOpacity) {
                    const borderR = parseInt(savedBorderColor.slice(1, 3), 16);
                    const borderG = parseInt(savedBorderColor.slice(3, 5), 16);
                    const borderB = parseInt(savedBorderColor.slice(5, 7), 16);
                    const rgbaBorderColor = `rgba(${borderR}, ${borderG}, ${borderB}, ${savedBorderOpacity / 100})`;
                    document.documentElement.style.setProperty('--border-color', rgbaBorderColor);
                }

                document.documentElement.style.setProperty('--rank-bg-color', rgbaRankBgColor);
                document.documentElement.style.setProperty('--text-color', savedTextColor);
                if (savedRrColor) {
                    document.documentElement.style.setProperty('--rr-color', savedRrColor);
                }

                // カラーピッカーの値を更新
                document.getElementById('rankBgColorPicker').value = savedRankBgColor;
                document.getElementById('rankBgOpacitySlider').value = savedRankBgOpacity;
                document.getElementById('rankBgOpacityValue').textContent = savedRankBgOpacity + '%';
                if (savedLastMatchBgColor && savedLastMatchBgOpacity) {
                    document.getElementById('lastMatchBgColorPicker').value = savedLastMatchBgColor;
                    document.getElementById('lastMatchBgOpacitySlider').value = savedLastMatchBgOpacity;
                    document.getElementById('lastMatchBgOpacityValue').textContent = savedLastMatchBgOpacity + '%';
                }
                document.getElementById('textColorPicker').value = savedTextColor;
                if (savedRrColor) {
                    document.getElementById('rrColorPicker').value = savedRrColor;
                }
                if (savedBorderColor) {
                    document.getElementById('borderColorPicker').value = savedBorderColor;
                }
                if (savedBorderOpacity) {
                    document.getElementById('borderOpacitySlider').value = savedBorderOpacity;
                    document.getElementById('borderOpacityValue').textContent = savedBorderOpacity + '%';
                }
            }

            // テーマ設定を適用
            if (savedTheme) {
                applyTheme(savedTheme);
            }
        }

        // ページ初期化処理
        function initializePage() {
            // URLパラメータを取得
            const urlParams = new URLSearchParams(window.location.search);
            const name = urlParams.get('name');
            const tag = urlParams.get('tag');
            const isOBS = urlParams.has('obs');
            const updateFreq = parseInt(urlParams.get('updateInterval')) || 60;

            // プレイヤー情報をグローバル変数に設定
            currentPlayerName = name;
            currentPlayerTag = tag;

            // URLパラメータからカスタマイズ設定を読み込み
            const urlRankBgColor = urlParams.get('rankBgColor');
            const urlRankBgOpacity = urlParams.get('rankBgOpacity');
            const urlLastMatchBgColor = urlParams.get('lastMatchBgColor');
            const urlLastMatchBgOpacity = urlParams.get('lastMatchBgOpacity');
            const urlTextColor = urlParams.get('textColor');
            const urlRrColor = urlParams.get('rrColor');
            const urlBorderColor = urlParams.get('borderColor');
            const urlBorderOpacity = urlParams.get('borderOpacity');
            const urlTheme = urlParams.get('theme');

            // URLパラメータから色設定を適用
            if (urlRankBgColor && urlRankBgOpacity && urlTextColor) {
                const rankR = parseInt(urlRankBgColor.slice(1, 3), 16);
                const rankG = parseInt(urlRankBgColor.slice(3, 5), 16);
                const rankB = parseInt(urlRankBgColor.slice(5, 7), 16);
                const rgbaRankBgColor = `rgba(${rankR}, ${rankG}, ${rankB}, ${urlRankBgOpacity / 100})`;
                document.documentElement.style.setProperty('--rank-bg-color', rgbaRankBgColor);
                document.documentElement.style.setProperty('--text-color', urlTextColor);

                if (urlLastMatchBgColor && urlLastMatchBgOpacity) {
                    const lastMatchR = parseInt(urlLastMatchBgColor.slice(1, 3), 16);
                    const lastMatchG = parseInt(urlLastMatchBgColor.slice(3, 5), 16);
                    const lastMatchB = parseInt(urlLastMatchBgColor.slice(5, 7), 16);
                    const rgbaLastMatchBgColor = `rgba(${lastMatchR}, ${lastMatchG}, ${lastMatchB}, ${urlLastMatchBgOpacity / 100})`;
                    document.documentElement.style.setProperty('--last-match-bg-color', rgbaLastMatchBgColor);
                }

                if (urlRrColor) {
                    document.documentElement.style.setProperty('--rr-color', urlRrColor);
                }

                if (urlBorderColor && urlBorderOpacity) {
                    const borderR = parseInt(urlBorderColor.slice(1, 3), 16);
                    const borderG = parseInt(urlBorderColor.slice(3, 5), 16);
                    const borderB = parseInt(urlBorderColor.slice(5, 7), 16);
                    const rgbaBorderColor = `rgba(${borderR}, ${borderG}, ${borderB}, ${urlBorderOpacity / 100})`;
                    document.documentElement.style.setProperty('--border-color', rgbaBorderColor);
                }
            } else {
                // URLパラメータに色設定がない場合はlocalStorageから読み込む
                loadSavedSettings();
                
                // デフォルト値を確実に設定（カスタマイズベース用）
                if (!localStorage.getItem('customRankBgColor')) {
                    document.documentElement.style.setProperty('--rank-bg-color', 'rgba(58, 68, 78, 1)');
                }
            }

            // テーマ設定を適用
            if (urlTheme) {
                applyTheme(urlTheme);
            } else {
                const savedTheme = localStorage.getItem('selectedTheme');
                if (savedTheme) {
                    applyTheme(savedTheme);
                }
            }

            // モーダルの外側をクリックしたら閉じる
            window.onclick = function(event) {
                const modal = document.getElementById('colorPickerModal');
                if (event.target == modal) {
                    closeColorPicker();
                }
            }

            if (name && tag) {
                // URLパラメータがある場合は入力フォームを非表示
                document.getElementById('inputSection').style.display = 'none';

                if (isOBS) {
                    // OBSモードの場合のスタイル調整
                    document.body.style.backgroundColor = 'transparent';
                    document.body.style.overflow = 'hidden';
                    // bodyにOBSモードクラスを追加
                    document.body.classList.add('obs-mode');

                    // ヘッダーナビゲーションを非表示
                    const headerElement = document.querySelector('.app-header');
                    if (headerElement) {
                        headerElement.style.display = 'none';
                    }

                    // 背景アニメーション要素を非表示
                    const backgroundElement = document.querySelector('.background');
                    if (backgroundElement) {
                        backgroundElement.style.display = 'none';
                    }

                    // オーバーレイのOBS向け位置調整（中央に配置）
                    const overlayElement = document.querySelector('.overlay');
                    if (overlayElement) {
                        overlayElement.style.position = 'absolute';
                        overlayElement.style.top = '50%';
                        overlayElement.style.left = '50%';
                        overlayElement.style.right = 'auto';
                        overlayElement.style.transform = 'translate(-50%, -50%)';
                        
                        // OBSブラウザソースサイズに応じてスケール調整
                        adjustOBSScale();
                    }

                    // 製作者紹介セクションを非表示
                    const authorSectionElement = document.querySelector('.author-section');
                    if (authorSectionElement) {
                        authorSectionElement.style.display = 'none';
                    }

                    // OBSモードでは自動更新を開始
                    console.log(`OBSモードで自動更新を有効化（${updateFreq}秒間隔）`);

                } else {
                    // 通常のブラウザ表示でのオーバーレイ位置調整
                    document.querySelector('.overlay').style.top = '50%';
                    document.querySelector('.overlay').style.transform = 'translateY(-50%)';
                }

                // プレイヤー情報を更新（初回）
                updatePlayerInfo(name, tag).then(() => {
                    // 初回更新完了後、OBSモードの場合は自動更新を開始
                    if (isOBS) {
                        startAutoUpdate(updateFreq);
                    }
                }).catch(error => {
                    console.error('初回データ取得エラー:', error);
                    // エラーが発生してもOBSモードなら自動更新を開始
                    if (isOBS) {
                        console.log('初回取得に失敗しましたが、OBSモードのため自動更新を開始します');
                        startOBSAutoUpdate(updateFreq);
                    }
                });
                
                // OBSモードの場合、初回更新と並行して自動更新も開始（フォールバック）
                if (isOBS) {
                    // 少し遅延させてから自動更新を確実に開始
                    setTimeout(() => {
                        if (!isAutoUpdateEnabled) {
                            console.log('フォールバック: OBS自動更新を強制開始');
                            startOBSAutoUpdate(updateFreq);
                        }
                    }, 2000);
                }
            } else if (isOBS) {
                // name, tag パラメータがないが OBS モードの場合
                document.getElementById('inputSection').style.display = 'none';
                
                // ヘッダーナビゲーションを非表示
                const headerElement = document.querySelector('.app-header');
                if (headerElement) {
                    headerElement.style.display = 'none';
                }
                
                // bodyにOBSモードクラスを追加
                document.body.classList.add('obs-mode');
                
                const backgroundElement = document.querySelector('.background');
                if (backgroundElement) {
                    backgroundElement.style.display = 'none';
                }
                // データがない旨を表示
                document.getElementById('rankText').textContent = '情報なし';
                document.getElementById('rrText').textContent = '';
                document.getElementById('lastMatchSection').style.display = 'none';
            }

            // 文字サイズ調整機能を初期化
            observeOverlayResize();

            // 初期化完了後に幅調整を実行（プレビュー画面のみ）
            setTimeout(() => {
                if (currentTheme === 'classic') {
                    resetLastMatchWidthForClassic();
                } else {
                    adjustLastMatchWidth();
                }
            }, 500);
            
            // プレビュー画面でより確実に幅調整を実行
            setTimeout(() => {
                if (currentTheme === 'classic') {
                    resetLastMatchWidthForClassic();
                } else {
                    adjustLastMatchWidth();
                }
            }, 1000);
            
            setTimeout(() => {
                if (currentTheme === 'classic') {
                    resetLastMatchWidthForClassic();
                } else {
                    adjustLastMatchWidth();
                }
            }, 2000);

            // カスタマイズボタンのイベントリスナーを設定
            const customizeButton = document.getElementById('customizeButton');
            if (customizeButton) {
                customizeButton.addEventListener('click', showColorPicker);
            }

            // テーマボタンのイベントリスナーを設定
            document.querySelectorAll('.theme-button').forEach(button => {
                button.addEventListener('click', function() {
                    const theme = this.getAttribute('data-theme');
                    applyTheme(theme);
                    // テーマ変更後に幅調整（プレビュー画面のみ）
                    setTimeout(() => {
                        if (theme === 'classic') {
                            resetLastMatchWidthForClassic();
                        } else {
                            adjustLastMatchWidth();
                        }
                    }, 300);
                });
            });
        }

        // 文字途切れ防止のための動的調整機能
        function adjustTextSize() {
            const overlay = document.querySelector('.overlay');
            if (!overlay) return;

            const rankName = overlay.querySelector('.rank-name');
            const rrText = overlay.querySelector('.rr');
            const lastMatchText = overlay.querySelector('.last-match-text');

            // ランク名の調整
            if (rankName) {
                adjustElementText(rankName, overlay);
            }

            // RRテキストの調整
            if (rrText) {
                adjustElementText(rrText, overlay);
            }

            // 前回のマッチテキストの調整
            if (lastMatchText) {
                adjustElementText(lastMatchText, overlay);
            }

            // 前回のマッチセクションの幅をランクセクションに合わせる
            adjustLastMatchWidth();

            // 全テーマで横幅を自動調整
            adjustOverlayWidth();
        }

        // 前回のマッチセクションの幅をランクセクションに合わせる機能（プレビュー画面のみ）
        function adjustLastMatchWidth() {
            // URLパラメータがある場合（URL生成後）は何もしない
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('name') || urlParams.has('tag')) {
                return;
            }
            
            // クラシックテーマの場合は元のデザインを保持
            if (currentTheme === 'classic') {
                console.log('クラシックテーマのため幅調整をスキップ');
                return;
            }
            
            const rankSection = document.querySelector('.rank-section');
            const lastMatchSection = document.querySelector('.last-match-section');
            
            if (!rankSection || !lastMatchSection) return;

            // ランクセクションの実際の幅を取得
            const rankSectionWidth = rankSection.offsetWidth;
            
            // プレビュー画面でのみCSS制約を解除して幅と位置を設定（クラシック以外のテーマ）
            lastMatchSection.style.width = rankSectionWidth + 'px';
            lastMatchSection.style.minWidth = rankSectionWidth + 'px';
            lastMatchSection.style.maxWidth = rankSectionWidth + 'px';
            lastMatchSection.style.boxSizing = 'border-box';
            lastMatchSection.style.margin = '0 auto'; // 中央揃え
            lastMatchSection.style.display = 'block'; // ブロック要素として表示
            
            // ランクセクションと前回のマッチセクションの位置を完全に同期
            const rankSectionStyle = window.getComputedStyle(rankSection);
            const rankSectionRect = rankSection.getBoundingClientRect();
            const overlay = rankSection.closest('.overlay');
            
            if (overlay) {
                const overlayRect = overlay.getBoundingClientRect();
                const rankLeftOffset = rankSectionRect.left - overlayRect.left;
                
                // 前回のマッチセクションをランクセクションと同じ左位置に配置
                lastMatchSection.style.marginLeft = rankLeftOffset + 'px';
                lastMatchSection.style.marginRight = 'auto';
            }
            
            console.log(`前回のマッチセクション幅調整（プレビュー画面・${currentTheme}テーマ）: ${rankSectionWidth}px`);
        }

        // クラシックテーマ用にスタイルをリセットする機能（再構築版）
        function resetLastMatchWidthForClassic() {
            // URLパラメータがある場合（URL生成後）は何もしない
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('name') || urlParams.has('tag')) {
                return;
            }
            
            const lastMatchSection = document.querySelector('.last-match-section');
            const rankSection = document.querySelector('.rank-section');
            if (!lastMatchSection || !rankSection) return;
            
            // クラシックテーマでは新しいCSS構造により自動的に幅が統一される
            // 追加のスタイル調整をリセット
            lastMatchSection.style.width = '';
            lastMatchSection.style.minWidth = '';
            lastMatchSection.style.maxWidth = '';
            lastMatchSection.style.marginLeft = '';
            lastMatchSection.style.marginRight = '';
            
            console.log('クラシックテーマ: CSS構造により自動幅統一');
        }

        // 全テーマの横幅自動調整機能（最小幅に調整）
        function adjustOverlayWidth() {
            const overlay = document.querySelector('.overlay');
            if (!overlay) return;

            // 全テーマでCSSによる最小幅調整が適用される
            console.log(`${currentTheme}テーマ: CSSによる最小幅調整を適用`);
        }

        function adjustElementText(element, container) {
            // 前回のマッチテキストは調整をスキップ（専用のコンテナ幅を使用するため）
            if (element && element.classList.contains('last-match-text')) {
                return;
            }

            const containerWidth = container.offsetWidth;
            const elementWidth = element.scrollWidth;
            
            // テキストがコンテナより大きい場合
            if (elementWidth > containerWidth * 0.9) {
                const currentFontSize = parseFloat(window.getComputedStyle(element).fontSize);
                const ratio = (containerWidth * 0.85) / elementWidth;
                const newFontSize = Math.max(currentFontSize * ratio, 10); // 最小10px
                
                element.style.fontSize = newFontSize + 'px';
            }
        }

        // OBSブラウザソースサイズに応じてオーバーレイをスケール調整
        function adjustOBSScale() {
            const overlay = document.querySelector('.overlay');
            if (!overlay || !document.body.classList.contains('obs-mode')) return;

            // ブラウザソースのサイズを取得
            const browserWidth = window.innerWidth;
            const browserHeight = window.innerHeight;
            
            // 基準サイズ（450x200）に対するスケール比を計算
            const baseWidth = 450;
            const baseHeight = 200;
            
            const scaleX = browserWidth / baseWidth;
            const scaleY = browserHeight / baseHeight;
            
            // 縦横比を保持してスケール（小さい方のスケールを使用）
            const scale = Math.min(scaleX, scaleY, 3); // 最大3倍まで
            
            // スケール適用
            overlay.style.transform = `translate(-50%, -50%) scale(${scale})`;
            
            console.log(`OBSスケール調整: ${browserWidth}x${browserHeight} → スケール ${scale.toFixed(2)}`);
        }

        // ウィンドウサイズ変更時にスケール調整
        window.addEventListener('resize', function() {
            if (document.body.classList.contains('obs-mode')) {
                adjustOBSScale();
            }
        });

        // オーバーレイのサイズ変更監視
        function observeOverlayResize() {
            const overlay = document.querySelector('.overlay');
            if (!overlay) return;

            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    setTimeout(adjustTextSize, 100); // 少し遅延させて確実に調整
                }
            });

            resizeObserver.observe(overlay);
        }

        // プレイヤー情報更新時に文字サイズも調整
        function updatePlayerInfoWithTextAdjustment(name, tag) {
            return updatePlayerInfo(name, tag).then(() => {
                setTimeout(adjustTextSize, 200); // データ更新後に調整
            });
        }

        async function updatePlayerInfo(name, tag) {
            try {
                console.log(`[${new Date().toLocaleTimeString()}] プレイヤー情報を取得中: ${name}#${tag}`);
                
                // 堅牢なAPI呼び出しを使用（改善されたfetchPlayerStats関数を使用）
                const stats = await fetchPlayerStats(name, tag);

                console.log('Stats response:', stats);

                if (stats && stats.data) {
                    const playerData = stats.data; // stats.data の内容を直接使用
                    console.log(`[${new Date().toLocaleTimeString()}] データ取得成功`);

                    // ランク情報を更新
                    const currentRank = playerData.currenttierpatched;
                    const rankingInTier = playerData.ranking_in_tier;
                    const mmrChange = playerData.mmr_change_to_last_game; // MMR変動値を取得

                    if (currentRank) {
                        // APIから取得した画像のURLを使用
                        if (playerData.images && playerData.images.large) {
                             document.getElementById('rankIcon').src = playerData.images.large;
                        } else {
                             // APIに画像URLがない場合はローカル画像を使用（フォールバック）
                             document.getElementById('rankIcon').src = getRankImageUrl(currentRank);
                        }

                        document.getElementById('rankText').textContent = currentRank;
                        document.getElementById('rrText').textContent = `${rankingInTier || 0}RR`;

                        // 直近のマッチ結果（MMR変動値）を更新
                        const lastMatchSection = document.getElementById('lastMatchSection');
                        const lastMatchText = document.getElementById('lastMatchText');
                        const mmrGaugeFill = lastMatchSection.querySelector('.mmr-gauge-fill');

                        // 現在のRR値に基づいてゲージを表示
                        if (rankingInTier !== undefined && rankingInTier !== null) {
                            // 前回のマッチの結果のみ表示
                            if (mmrChange !== undefined) {
                                const sign = mmrChange >= 0 ? '+' : '';
                                lastMatchText.textContent = `前回のマッチ ${sign}${mmrChange}pts`;
                            } else {
                                lastMatchText.textContent = '前回のマッチ';
                            }

                            // ゲージの幅を計算（RR値 / 100 * 100 = パーセンテージ）
                            const gaugePercentage = Math.min(100, Math.max(0, rankingInTier)); // 0-100の範囲に制限
                            
                            // 常に緑色のゲージ（現在のランクポイントを表すため）
                            mmrGaugeFill.style.width = `${gaugePercentage}%`;
                            mmrGaugeFill.style.backgroundColor = '#4CAF50'; // 緑
                            mmrGaugeFill.style.left = '0';
                            mmrGaugeFill.style.right = 'auto';

                            lastMatchSection.style.display = 'flex'; // ゲージ表示のためflexに変更
                        } else {
                            lastMatchSection.style.display = 'none';
                        }

                        console.log(`[${new Date().toLocaleTimeString()}] ランク情報更新: ${currentRank} ${rankingInTier}RR`);

                    } else { // currentRank がない場合 (例: ランクなし)
                        document.getElementById('rankIcon').src = 'assets/images/ranks/ランクなし.png';
                        document.getElementById('rankText').textContent = 'ランクなし';
                        document.getElementById('rrText').textContent = '';
                        document.getElementById('lastMatchSection').style.display = 'none';
                        console.log(`[${new Date().toLocaleTimeString()}] ランク情報なし`);
                    }

                } else { // stats または stats.data が存在しない場合
                    document.getElementById('rankIcon').src = 'assets/images/ranks/ランクなし.png';
                    document.getElementById('rankText').textContent = 'データなし';
                    document.getElementById('rrText').textContent = '';
                    document.getElementById('lastMatchSection').style.display = 'none';
                    console.log(`[${new Date().toLocaleTimeString()}] API応答にデータが含まれていません`);
                }
                
                // 最終更新時刻を更新
                updateAutoUpdateStatus();

                // プレイヤー情報更新後に文字サイズと横幅を調整
                setTimeout(() => {
                    adjustTextSize();
                    adjustOverlayWidth();
                }, 300);

            } catch (error) {
                console.error(`[${new Date().toLocaleTimeString()}] Error updating player info:`, error);
                
                // エラー発生時も表示をリセット
                document.getElementById('rankIcon').src = 'assets/images/ranks/ランクなし.png';
                document.getElementById('rankText').textContent = 'エラー';
                document.getElementById('rrText').textContent = '';
                document.getElementById('lastMatchSection').style.display = 'none';
                
                // エラー時も最終更新時刻を更新
                updateAutoUpdateStatus();
            }
        }

        function generateURL() {
            const playerName = document.getElementById('playerName').value;
            const playerTag = document.getElementById('playerTag').value;
            
            if (!playerName || !playerTag) {
                alert('プレイヤー名とタグを入力してください。');
                return;
            }

            const currentURL = window.location.href.split('?')[0];
            const urlParams = new URLSearchParams();
            urlParams.append('name', playerName);
            urlParams.append('tag', playerTag);
            urlParams.append('obs', ''); // OBSモードパラメータをデフォルトで追加
            urlParams.append('updateInterval', '30'); // 自動更新間隔（30秒）に短縮

            // カスタマイズ設定をURLパラメータとして追加
            const savedRankBgColor = localStorage.getItem('customRankBgColor');
            const savedRankBgOpacity = localStorage.getItem('customRankBgOpacity');
            const savedLastMatchBgColor = localStorage.getItem('customLastMatchBgColor');
            const savedLastMatchBgOpacity = localStorage.getItem('customLastMatchBgOpacity');
            const savedTextColor = localStorage.getItem('customTextColor');
            const savedRrColor = localStorage.getItem('customRrColor');
            const savedBorderColor = localStorage.getItem('customBorderColor');
            const savedBorderOpacity = localStorage.getItem('customBorderOpacity');
            const savedTheme = localStorage.getItem('selectedTheme');

            if (savedRankBgColor) urlParams.append('rankBgColor', savedRankBgColor);
            if (savedRankBgOpacity) urlParams.append('rankBgOpacity', savedRankBgOpacity);
            if (savedLastMatchBgColor) urlParams.append('lastMatchBgColor', savedLastMatchBgColor);
            if (savedLastMatchBgOpacity) urlParams.append('lastMatchBgOpacity', savedLastMatchBgOpacity);
            if (savedTextColor) urlParams.append('textColor', savedTextColor);
            if (savedRrColor) urlParams.append('rrColor', savedRrColor);
            if (savedBorderColor) urlParams.append('borderColor', savedBorderColor);
            if (savedBorderOpacity) urlParams.append('borderOpacity', savedBorderOpacity);
            if (savedTheme) urlParams.append('theme', savedTheme);
            
            const newURL = `${currentURL}?${urlParams.toString()}`;
            document.getElementById('generatedURL').value = newURL;
        }

        function copyURL() {
            const urlInput = document.getElementById('generatedURL');
            urlInput.select();
            document.execCommand('copy');
            alert('URLをコピーしました！');
        }

        function manualUpdate() {
            console.log('手動更新が呼び出されました');
            updatePlayerInfo(currentPlayerName, currentPlayerTag).then(() => {
                console.log('手動更新が成功しました');
            }).catch(error => {
                console.error('手動更新中にエラーが発生しました:', error);
            });
        }

        // チュートリアルの開閉機能
        function toggleTutorial() {
            const content = document.getElementById('tutorialContent');
            const arrow = document.getElementById('tutorialArrow');
            
            if (content.classList.contains('expanded')) {
                // 閉じる
                content.classList.remove('expanded');
                arrow.classList.remove('rotated');
            } else {
                // 開く
                content.classList.add('expanded');
                arrow.classList.add('rotated');
            }
        }

        // ページ読み込み時の初期化
        window.addEventListener('DOMContentLoaded', function() {
            initializePage();
        });
    </script>
</body>
</html> 
